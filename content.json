{"meta":{"title":"我的博客","subtitle":"","description":"123","author":"xxx","url":"http://example.com","root":"/"},"pages":[{"title":"tages","date":"2022-10-27T05:36:48.000Z","updated":"2022-10-27T05:36:48.136Z","comments":true,"path":"tages/index.html","permalink":"http://example.com/tages/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-10-27T05:49:26.348Z","updated":"2022-10-27T05:49:26.348Z","comments":true,"path":"tag/index.html","permalink":"http://example.com/tag/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-10-04T13:46:24.000Z","updated":"2022-10-27T05:40:12.728Z","comments":true,"path":"category/index.html","permalink":"http://example.com/category/index.html","excerpt":"","text":""},{"title":"","date":"2022-10-07T07:13:44.945Z","updated":"2022-10-07T07:13:44.945Z","comments":true,"path":"404.html","permalink":"http://example.com/404.html","excerpt":"","text":"当前访问的页面不存在"}],"posts":[{"title":"es6中decorator以及module的理解","slug":"es6中decorator以及module的理解","date":"2022-10-13T06:05:20.000Z","updated":"2022-10-13T06:05:20.144Z","comments":true,"path":"2022/10/13/es6中decorator以及module的理解/","link":"","permalink":"http://example.com/2022/10/13/es6%E4%B8%ADdecorator%E4%BB%A5%E5%8F%8Amodule%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"html5","slug":"html5","date":"2022-10-05T01:29:10.000Z","updated":"2022-10-05T01:37:15.506Z","comments":true,"path":"2022/10/05/html5/","link":"","permalink":"http://example.com/2022/10/05/html5/","excerpt":"","text":"什么是html5​ HTML5是构建Web内容的一种语言描述方式。HTML5是互联网的下一代标准，是构建以及呈现互联网内容的一种语言方式．被认为是互联网的核心技术之一。 ​ HTML5是Web中核心语言HTML的规范，用户使用任何手段进行网页浏览时看到的内容原本都是HTML格式的，在浏览器中通过一些技术处理将其转换成为了可识别的信息。 html5新增标签​ video 播放视频 ​ audio 播放音频 ​ canvas 位图 ​ svg矢量图 ​ time时间 ​ mark高亮 ​ output计算值 ​ progress进度条 ​ menu菜单 ​ header头部","categories":[{"name":"html","slug":"html","permalink":"http://example.com/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"}]},{"title":"上传文件过大解决方法","slug":"上传文件过大解决方法","date":"2021-05-21T12:40:13.000Z","updated":"2022-10-13T06:34:57.966Z","comments":true,"path":"2021/05/21/上传文件过大解决方法/","link":"","permalink":"http://example.com/2021/05/21/%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"是什么断点续传不管怎样简单的需求，在量级达到一定层次时，都会变得异常复杂 文件上传简单，文件变大就复杂 上传大文件时，以下几个变量会影响我们的用户体验 服务器处理数据的能力 请求超时 网络波动 上传时间会变长，高频次文件上传失败，失败后又需要重新上传等等 为了解决上述问题，我们需要对大文件上传单独处理 这里涉及到分片上传及断点续传两个概念 分片上传分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（Part）来进行分片上传 如下图 上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件 大致流程如下： 将需要上传的文件按照一定的分割规则，分割成相同大小的数据块； 初始化一个分片上传任务，返回本次分片上传唯一标识； 按照一定的策略（串行或并行）发送各个分片数据块； 发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件 断点续传断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分 每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载。用户可以节省时间，提高速度 一般实现方式有两种： 服务器端返回，告知从哪开始 浏览器端自行处理 上传过程中将文件在服务器写为临时文件，等全部写完了（文件上传完），将此临时文件重命名为正式文件即可 如果中途上传中断过，下次上传的时候根据当前临时文件大小，作为在客户端读取文件的偏移量，从此位置继续读取文件数据块，上传到服务器从此偏移量继续写入文件即可 实现思路整体思路比较简单，拿到文件，保存文件唯一性标识，切割文件，分段上传，每次上传一段，根据唯一性标识判断文件上传进度，直到文件的全部片段上传完毕 下面的内容都是伪代码 读取文件内容： 1234const input = document.querySelector(&#x27;input&#x27;);input.addEventListener(&#x27;change&#x27;, function() &#123; var file = this.files[0];&#125;); 可以使用md5实现文件的唯一性 1const md5code = md5(file); 然后开始对文件进行分割 123456var reader = new FileReader();reader.readAsArrayBuffer(file);reader.addEventListener(&quot;load&quot;, function(e) &#123; //每10M切割一段,这里只做一个切割演示，实际切割需要循环切割， var slice = e.target.result.slice(0, 10*1024*1024);&#125;); h5上传一个（一片） 123456789101112131415161718const formdata = new FormData();formdata.append(&#x27;0&#x27;, slice);//这里是有一个坑的，部分设备无法获取文件名称，和文件类型，这个在最后给出解决方案formdata.append(&#x27;filename&#x27;, file.filename);var xhr = new XMLHttpRequest();xhr.addEventListener(&#x27;load&#x27;, function() &#123; //xhr.responseText&#125;);xhr.open(&#x27;POST&#x27;, &#x27;&#x27;);xhr.send(formdata);xhr.addEventListener(&#x27;progress&#x27;, updateProgress);xhr.upload.addEventListener(&#x27;progress&#x27;, updateProgress);function updateProgress(event) &#123; if (event.lengthComputable) &#123; //进度条 &#125;&#125; 这里给出常见的图片和视频的文件类型判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495function checkFileType(type, file, back) &#123;/*** type png jpg mp4 ...* file input.change=&gt; this.files[0]* back callback(boolean)*/ var args = arguments; if (args.length != 3) &#123; back(0); &#125; var type = args[0]; // type = &#x27;(png|jpg)&#x27; , &#x27;png&#x27; var file = args[1]; var back = typeof args[2] == &#x27;function&#x27; ? args[2] : function() &#123;&#125;; if (file.type == &#x27;&#x27;) &#123; // 如果系统无法获取文件类型，则读取二进制流，对二进制进行解析文件类型 var imgType = [ &#x27;ff d8 ff&#x27;, //jpg &#x27;89 50 4e&#x27;, //png &#x27;0 0 0 14 66 74 79 70 69 73 6F 6D&#x27;, //mp4 &#x27;0 0 0 18 66 74 79 70 33 67 70 35&#x27;, //mp4 &#x27;0 0 0 0 66 74 79 70 33 67 70 35&#x27;, //mp4 &#x27;0 0 0 0 66 74 79 70 4D 53 4E 56&#x27;, //mp4 &#x27;0 0 0 0 66 74 79 70 69 73 6F 6D&#x27;, //mp4 &#x27;0 0 0 18 66 74 79 70 6D 70 34 32&#x27;, //m4v &#x27;0 0 0 0 66 74 79 70 6D 70 34 32&#x27;, //m4v &#x27;0 0 0 14 66 74 79 70 71 74 20 20&#x27;, //mov &#x27;0 0 0 0 66 74 79 70 71 74 20 20&#x27;, //mov &#x27;0 0 0 0 6D 6F 6F 76&#x27;, //mov &#x27;4F 67 67 53 0 02&#x27;, //ogg &#x27;1A 45 DF A3&#x27;, //ogg &#x27;52 49 46 46 x x x x 41 56 49 20&#x27;, //avi (RIFF fileSize fileType LIST)(52 49 46 46,DC 6C 57 09,41 56 49 20,4C 49 53 54) ]; var typeName = [ &#x27;jpg&#x27;, &#x27;png&#x27;, &#x27;mp4&#x27;, &#x27;mp4&#x27;, &#x27;mp4&#x27;, &#x27;mp4&#x27;, &#x27;mp4&#x27;, &#x27;m4v&#x27;, &#x27;m4v&#x27;, &#x27;mov&#x27;, &#x27;mov&#x27;, &#x27;mov&#x27;, &#x27;ogg&#x27;, &#x27;ogg&#x27;, &#x27;avi&#x27;, ]; var sliceSize = /png|jpg|jpeg/.test(type) ? 3 : 12; var reader = new FileReader(); reader.readAsArrayBuffer(file); reader.addEventListener(&quot;load&quot;, function(e) &#123; var slice = e.target.result.slice(0, sliceSize); reader = null; if (slice &amp;&amp; slice.byteLength == sliceSize) &#123; var view = new Uint8Array(slice); var arr = []; view.forEach(function(v) &#123; arr.push(v.toString(16)); &#125;); view = null; var idx = arr.join(&#x27; &#x27;).indexOf(imgType); if (idx &gt; -1) &#123; back(typeName[idx]); &#125; else &#123; arr = arr.map(function(v) &#123; if (i &gt; 3 &amp;&amp; i &lt; 8) &#123; return &#x27;x&#x27;; &#125; return v; &#125;); var idx = arr.join(&#x27; &#x27;).indexOf(imgType); if (idx &gt; -1) &#123; back(typeName[idx]); &#125; else &#123; back(false); &#125; &#125; &#125; else &#123; back(false); &#125; &#125;); &#125; else &#123; var type = file.name.match(/\\.(\\w+)$/)[1]; back(type); &#125;&#125; 调用方法如下 1234checkFileType(&#x27;(mov|mp4|avi)&#x27;,file,function(fileType)&#123; // fileType = mp4, // 如果file的类型不在枚举之列，则返回false&#125;); 上面上传文件的一步，可以改成： 1formdata.append(&#x27;filename&#x27;, md5code+&#x27;.&#x27;+fileType); 有了切割上传后，也就有了文件唯一标识信息，断点续传变成了后台的一个小小的逻辑判断 后端主要做的内容为：根据前端传给后台的md5值，到服务器磁盘查找是否有之前未完成的文件合并信息（也就是未完成的半成品文件切片），取到之后根据上传切片的数量，返回数据告诉前端开始从第几节上传 如果想要暂停切片的上传，可以使用XMLHttpRequest的 abort方法 使用场景 大文件加速上传：当文件大小超过预期大小时，使用分片上传可实现并行上传多个 Part， 以加快上传速度 网络环境较差：建议使用分片上传。当出现上传失败的时候，仅需重传失败的Part 流式上传：可以在需要上传的文件大小还不确定的情况下开始上传。这种场景在视频监控等行业应用中比较常见 小结当前的伪代码，只是提供一个简单的思路，想要把事情做到极致，我们还需要考虑到更多场景，比如 切片上传失败怎么办 上传过程中刷新页面怎么办 如何进行并行上传 切片什么时候按数量切，什么时候按大小切 如何结合 Web Worker 处理大文件上传 如何实现秒传","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"spa单页面","slug":"spa单页面","date":"2020-11-02T10:28:02.000Z","updated":"2022-10-05T06:49:06.063Z","comments":true,"path":"2020/11/02/spa单页面/","link":"","permalink":"http://example.com/2020/11/02/spa%E5%8D%95%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"什么是SPASPA（single-page application），翻译过来就是单页应用SPA是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中，所有必要的代码（HTML、JavaScript和CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）动态装载适当的资源并添加到页面页面在任何时间点都不会重新加载，也不会将控制转移到其他页面举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内容，而杯子始终是那个杯子结构如下图 我们熟知的JS框架如react,vue,angular,ember都属于SPA SPA和MPA的区别上面大家已经对单页面有所了解了，下面来讲讲多页应用MPA（MultiPage-page application），翻译过来就是多页应用在MPA中，每个页面都是一个主页面，都是独立的当我们在访问另一个页面的时候，都需要重新加载html、css、js文件，公共文件则根据需求按需加载如下图 单页应用与多页应用的区别 单页面应用（SPA） 多页面应用（MPA） 组成 一个主页面和多个页面片段 多个主页面 刷新方式 局部刷新 整页刷新 url模式 哈希模式 历史模式 SEO搜索引擎优化 难实现，可使用SSR方式改善 容易实现 数据传递 容易 通过url、cookie、localStorage等传递 页面切换 速度快，用户体验良好 切换加载资源，速度慢，用户体验差 维护成本 相对容易 相对复杂 单页应用优缺点优点： 具有桌面应用的即时性、网站的可移植性和可访问性 用户体验好、快，内容的改变不需要重新加载整个页面 良好的前后端分离，分工更明确 缺点： 不利于搜索引擎的抓取 首次渲染速度相对较慢 实现一个SPA原理 监听地址栏中hash变化驱动界面变化 用pushsate记录浏览器的历史，驱动界面发送变化 实现hash 模式核心通过监听url中的hash来进行路由跳转 123456789101112131415161718192021222324252627// 定义 Router class Router &#123; constructor () &#123; this.routes = &#123;&#125;; // 存放路由path及callback this.currentUrl = &#x27;&#x27;; // 监听路由change调用相对应的路由回调 window.addEventListener(&#x27;load&#x27;, this.refresh, false); window.addEventListener(&#x27;hashchange&#x27;, this.refresh, false); &#125; route(path, callback)&#123; this.routes[path] = callback; &#125; push(path) &#123; this.routes[path] &amp;&amp; this.routes[path]() &#125; &#125; // 使用 router window.miniRouter = new Router(); miniRouter.route(&#x27;/&#x27;, () =&gt; console.log(&#x27;page1&#x27;)) miniRouter.route(&#x27;/page2&#x27;, () =&gt; console.log(&#x27;page2&#x27;)) miniRouter.push(&#x27;/&#x27;) // page1 miniRouter.push(&#x27;/page2&#x27;) // page2 history模式history 模式核心借用 HTML5 history api，api 提供了丰富的 router 相关属性先了解一个几个相关的api history.pushState 浏览器历史纪录添加记录 history.replaceState修改浏览器历史纪录中当前纪录 history.popState 当 history 发生变化时触发 12345678910111213141516171819202122232425262728293031323334353637// 定义 Router class Router &#123; constructor () &#123; this.routes = &#123;&#125;; this.listerPopState() &#125; init(path) &#123; history.replaceState(&#123;path: path&#125;, null, path); this.routes[path] &amp;&amp; this.routes[path](); &#125; route(path, callback)&#123; this.routes[path] = callback; &#125; push(path) &#123; history.pushState(&#123;path: path&#125;, null, path); this.routes[path] &amp;&amp; this.routes[path](); &#125; listerPopState () &#123; window.addEventListener(&#x27;popstate&#x27; , e =&gt; &#123; const path = e.state &amp;&amp; e.state.path; this.routers[path] &amp;&amp; this.routers[path]() &#125;) &#125; &#125; // 使用 Router window.miniRouter = new Router(); miniRouter.route(&#x27;/&#x27;, ()=&gt; console.log(&#x27;page1&#x27;)) miniRouter.route(&#x27;/page2&#x27;, ()=&gt; console.log(&#x27;page2&#x27;)) // 跳转 miniRouter.push(&#x27;/page2&#x27;) // page2","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"v-show和v-if的区别","slug":"v-show和v-if的区别","date":"2020-11-02T10:28:02.000Z","updated":"2022-10-05T06:49:12.104Z","comments":true,"path":"2020/11/02/v-show和v-if的区别/","link":"","permalink":"http://example.com/2020/11/02/v-show%E5%92%8Cv-if%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"v-show与v-if的共同点我们都知道在 vue 中 v-show 与 v-if 的作用效果是相同的(不含v-else)，都能控制元素在页面是否显示 在用法上也是相同的 12&lt;Model v-show=&quot;isShow&quot; /&gt;&lt;Model v-if=&quot;isShow&quot; /&gt; 当表达式为true的时候，都会占据页面的位置 当表达式都为false时，都不会占据页面位置 v-show与v-if的区别 控制手段不同 编译过程不同 编译条件不同 控制手段：v-show隐藏则是为该元素添加css--display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除 编译过程：v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换 编译条件：v-if是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。只有渲染条件为假时，并不做操作，直到为真才渲染 v-show 由false变为true的时候不会触发组件的生命周期 v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗 v-show与v-if原理分析具体解析流程这里不展开讲，大致流程如下 将模板template转为ast结构的JS对象 用ast得到的JS对象拼装render和staticRenderFns函数 render和staticRenderFns函数被调用后生成虚拟VNODE节点，该节点包含创建DOM节点所需信息 vm.patch函数通过虚拟DOM算法利用VNODE节点创建真实DOM节点 v-show原理不管初始条件是什么，元素总是会被渲染 我们看一下在vue中是如何实现的 代码很好理解，有transition就执行transition，没有就直接设置display属性 12345678910111213141516171819202122// https://github.com/vuejs/vue-next/blob/3cd30c5245da0733f9eb6f29d220f39c46518162/packages/runtime-dom/src/directives/vShow.tsexport const vShow: ObjectDirective&lt;VShowElement&gt; = &#123; beforeMount(el, &#123; value &#125;, &#123; transition &#125;) &#123; el._vod = el.style.display === &#x27;none&#x27; ? &#x27;&#x27; : el.style.display if (transition &amp;&amp; value) &#123; transition.beforeEnter(el) &#125; else &#123; setDisplay(el, value) &#125; &#125;, mounted(el, &#123; value &#125;, &#123; transition &#125;) &#123; if (transition &amp;&amp; value) &#123; transition.enter(el) &#125; &#125;, updated(el, &#123; value, oldValue &#125;, &#123; transition &#125;) &#123; // ... &#125;, beforeUnmount(el, &#123; value &#125;) &#123; setDisplay(el, value) &#125;&#125; v-if原理v-if在实现上比v-show要复杂的多，因为还有else else-if 等条件需要处理，这里我们也只摘抄源码中处理 v-if 的一小部分 返回一个node节点，render函数通过表达式的值来决定是否生成DOM 1234567891011121314151617181920212223242526// https://github.com/vuejs/vue-next/blob/cdc9f336fd/packages/compiler-core/src/transforms/vIf.tsexport const transformIf = createStructuralDirectiveTransform( /^(if|else|else-if)$/, (node, dir, context) =&gt; &#123; return processIf(node, dir, context, (ifNode, branch, isRoot) =&gt; &#123; // ... return () =&gt; &#123; if (isRoot) &#123; ifNode.codegenNode = createCodegenNodeForBranch( branch, key, context ) as IfConditionalExpression &#125; else &#123; // attach this branch&#x27;s codegen node to the v-if root. const parentCondition = getParentCondition(ifNode.codegenNode!) parentCondition.alternate = createCodegenNodeForBranch( branch, key + ifNode.branches.length - 1, context ) &#125; &#125; &#125;) &#125;) v-show与v-if的使用场景v-if 与 v-show 都能控制dom元素在页面的显示 v-if 相比 v-show 开销更大的（直接操作dom节点增加与删除） 如果需要非常频繁地切换，则使用 v-show 较好 如果在运行时条件很少改变，则使用 v-if 较好","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"Vue中封装axios","slug":"Vue中封装axios","date":"2020-10-23T05:04:15.000Z","updated":"2022-10-12T01:11:14.516Z","comments":true,"path":"2020/10/23/Vue中封装axios/","link":"","permalink":"http://example.com/2020/10/23/Vue%E4%B8%AD%E5%B0%81%E8%A3%85axios/","excerpt":"","text":"axios是什么axios 是一个轻量的 HTTP客户端 基于 XMLHttpRequest 服务来执行 HTTP 请求，支持丰富的配置，支持 Promise，支持浏览器端和 Node.js 端。自Vue2.0起，尤大宣布取消对 vue-resource 的官方推荐，转而推荐 axios。现在 axios 已经成为大部分 Vue 开发者的首选 特性 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换JSON 数据 客户端支持防御XSRF 基本使用安装 1234// 项目中安装npm install axios --S// cdn 引入&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 导入 1import axios from &#x27;axios&#x27; 发送请求 1234567891011axios(&#123; url:&#x27;xxx&#x27;, // 设置请求的地址 method:&quot;GET&quot;, // 设置请求方法 params:&#123; // get请求使用params进行参数凭借,如果是post请求用data type: &#x27;&#x27;, page: 1 &#125;&#125;).then(res =&gt; &#123; // res为后端返回的数据 console.log(res); &#125;) 并发请求axios.all([]) 12345678910111213function getUserAccount() &#123; return axios.get(&#x27;/user/12345&#x27;);&#125;function getUserPermissions() &#123; return axios.get(&#x27;/user/12345/permissions&#x27;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (res1, res2) &#123; // res1第一个请求的返回的内容，res2第二个请求返回的内容 // 两个请求都执行完成才会执行&#125;)); 为什么要封装axios 的 API 很友好，你完全可以很轻松地在项目中直接使用。 不过随着项目规模增大，如果每发起一次HTTP请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍 这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中二次封装一下 axios 再使用 举个例子： 12345678910111213141516171819202122232425262728axios(&#x27;http://localhost:3000/data&#x27;, &#123; // 配置代码 method: &#x27;GET&#x27;, timeout: 1000, withCredentials: true, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, Authorization: &#x27;xxx&#x27;, &#125;, transformRequest: [function (data, headers) &#123; return data; &#125;], // 其他请求配置...&#125;).then((data) =&gt; &#123; // todo: 真正业务逻辑代码 console.log(data);&#125;, (err) =&gt; &#123; // 错误处理代码 if (err.response.status === 401) &#123; // handle authorization error &#125; if (err.response.status === 403) &#123; // handle server forbidden error &#125; // 其他错误处理..... console.log(err);&#125;); 如果每个页面都发送类似的请求，都要写一堆的配置与错误处理，就显得过于繁琐了 这时候我们就需要对axios进行二次封装，让使用更为便利 如何封装封装的同时，你需要和 后端协商好一些约定，请求头，状态码，请求超时时间……. 设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分 请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务) 状态码: 根据接口返回的不同status ， 来执行不同的业务，这块需要和后端约定好 请求方法：根据get、post等方法进行一个再次封装，使用起来更为方便 请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问 响应拦截器： 这块就是根据 后端&#96;返回来的状态码判定执行不同业务 设置接口请求前缀利用node环境变量来作判断，用来区分开发、测试、生产环境 12345if (process.env.NODE_ENV === &#x27;development&#x27;) &#123; axios.defaults.baseURL = &#x27;http://dev.xxx.com&#x27;&#125; else if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; axios.defaults.baseURL = &#x27;http://prod.xxx.com&#x27;&#125; 在本地调试的时候，还需要在vue.config.js文件中配置devServer实现代理转发，从而实现跨域 1234567891011devServer: &#123; proxy: &#123; &#x27;/proxyApi&#x27;: &#123; target: &#x27;http://dev.xxx.com&#x27;, changeOrigin: true, pathRewrite: &#123; &#x27;/proxyApi&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125; 设置请求头与超时时间大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置 1234567891011121314const service = axios.create(&#123; ... timeout: 30000, // 请求 30s 超时 headers: &#123; get: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded;charset=utf-8&#x27; // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来 &#125;, post: &#123; &#x27;Content-Type&#x27;: &#x27;application/json;charset=utf-8&#x27; // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来 &#125; &#125;,&#125;) 封装请求方法先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去 1234567891011121314151617181920212223242526272829303132333435363738394041424344// get 请求export function httpGet(&#123; url, params = &#123;&#125;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get(url, &#123; params &#125;).then((res) =&gt; &#123; resolve(res.data) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;// post// post请求export function httpPost(&#123; url, data = &#123;&#125;, params = &#123;&#125;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios(&#123; url, method: &#x27;post&#x27;, transformRequest: [function (data) &#123; let ret = &#x27;&#x27; for (let it in data) &#123; ret += encodeURIComponent(it) + &#x27;=&#x27; + encodeURIComponent(data[it]) + &#x27;&amp;&#x27; &#125; return ret &#125;], // 发送的数据 data, // \burl参数 params &#125;).then(res =&gt; &#123; resolve(res.data) &#125;) &#125;)&#125; 把封装的方法放在一个api.js文件中 12import &#123; httpGet, httpPost &#125; from &#x27;./http&#x27;export const getorglist = (params = &#123;&#125;) =&gt; httpGet(&#123; url: &#x27;apps/api/org/list&#x27;, params &#125;) 页面中就能直接调用 123456// .vueimport &#123; getorglist &#125; from &#x27;@/assets/js/api&#x27;getorglist(&#123; id: 200 &#125;).then(res =&gt; &#123; console.log(res)&#125;) 这样可以把api统一管理起来，以后维护修改只需要在api.js文件操作即可 请求拦截器请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便 1234567891011// 请求拦截器axios.interceptors.request.use( config =&gt; &#123; // 每次发送请求之前判断是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的 token &amp;&amp; (config.headers.Authorization = token) return config &#125;, error =&gt; &#123; return Promise.error(error) &#125;) 响应拦截器响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权 1234567891011121314151617181920212223// 响应拦截器axios.interceptors.response.use(response =&gt; &#123; // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) &#123; if (response.data.code === 511) &#123; // 未授权调取授权接口 &#125; else if (response.data.code === 510) &#123; // 未登录跳转登录页 &#125; else &#123; return Promise.resolve(response) &#125; &#125; else &#123; return Promise.reject(response) &#125;&#125;, error =&gt; &#123; // 我们可以在这里对异常状态作统一处理 if (error.response.status) &#123; // 处理请求失败的情况 // 对不同返回码对相应处理 return Promise.reject(error.response) &#125;&#125;) 小结 封装是编程中很有意义的手段，简单的axios封装，就可以让我们可以领略到它的魅力 封装 axios 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"为什么v-if和v-for不建议一同使用","slug":"为什么v-if和v-for不建议一同使用","date":"2020-10-21T10:33:02.000Z","updated":"2022-10-12T01:15:12.036Z","comments":true,"path":"2020/10/21/为什么v-if和v-for不建议一同使用/","link":"","permalink":"http://example.com/2020/10/21/%E4%B8%BA%E4%BB%80%E4%B9%88v-if%E5%92%8Cv-for%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8/","excerpt":"","text":"作用v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而 item 则是被迭代的数组元素的别名 在 v-for 的时候，建议设置key值，并且保证每个key值是独一无二的，这便于diff算法进行优化 两者在用法上 12345&lt;Modal v-if=&quot;isShow&quot; /&gt;&lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt; &#123;&#123; item.label &#125;&#125;&lt;/li&gt; 优先级v-if与v-for都是vue模板系统中的指令 在vue模板编译的时候，会将指令系统转化成可执行的render函数 示例编写一个p标签，同时使用v-if与 v-for 12345&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;isShow&quot; v-for=&quot;item in items&quot;&gt; &#123;&#123; item.title &#125;&#125; &lt;/p&gt;&lt;/div&gt; 创建vue实例，存放isShow与items数据 123456789101112131415const app = new Vue(&#123; el: &quot;#app&quot;, data() &#123; return &#123; items: [ &#123; title: &quot;foo&quot; &#125;, &#123; title: &quot;baz&quot; &#125;] &#125; &#125;, computed: &#123; isShow() &#123; return this.items &amp;&amp; this.items.length &gt; 0 &#125; &#125;&#125;) 模板指令的代码都会生成在render函数中，通过app.$options.render就能得到渲染函数 123456ƒ anonymous() &#123; with (this) &#123; return _c(&#x27;div&#x27;, &#123; attrs: &#123; &quot;id&quot;: &quot;app&quot; &#125; &#125;, _l((items), function (item) &#123; return (isShow) ? _c(&#x27;p&#x27;, [_v(&quot;\\n&quot; + _s(item.title) + &quot;\\n&quot;)]) : _e() &#125;), 0) &#125;&#125; _l是vue的列表渲染函数，函数内部都会进行一次if判断 初步得到结论：v-for优先级是比v-if高 再将v-for与v-if置于不同标签 12345&lt;div id=&quot;app&quot;&gt; &lt;template v-if=&quot;isShow&quot;&gt; &lt;p v-for=&quot;item in items&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt; &lt;/template&gt;&lt;/div&gt; 再输出下render函数 123456ƒ anonymous() &#123; with(this)&#123;return _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;, [(isShow)?[_v(&quot;\\n&quot;), _l((items),function(item)&#123;return _c(&#x27;p&#x27;,[_v(_s(item.title))])&#125;)]:_e()],2)&#125;&#125; 这时候我们可以看到，v-for与v-if作用在不同标签时候，是先进行判断，再进行列表的渲染 我们再在查看下vue源码 源码位置：\\vue-dev\\src\\compiler\\codegen\\index.js 1234567891011121314151617181920export function genElement (el: ASTElement, state: CodegenState): string &#123; if (el.parent) &#123; el.pre = el.pre || el.parent.pre &#125; if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123; return genStatic(el, state) &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123; return genOnce(el, state) &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123; return genFor(el, state) &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state) &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123; return genChildren(el, state) || &#x27;void 0&#x27; &#125; else if (el.tag === &#x27;slot&#x27;) &#123; return genSlot(el, state) &#125; else &#123; // component or element ...&#125; 在进行if判断的时候，v-for是比v-if先进行判断 最终结论：v-for优先级比v-if高 注意事项 永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断） 如果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环 123&lt;template v-if=&quot;isShow&quot;&gt; &lt;p v-for=&quot;item in items&quot;&gt;&lt;/template&gt; 如果条件出现在循环内部，可通过计算属性computed提前过滤掉那些不需要显示的项 1234567computed: &#123; items: function() &#123; return this.list.filter(function (item) &#123; return item.isShow &#125;) &#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue中keep-alive缓存原理","slug":"vue中keep-alive缓存原理","date":"2020-10-13T13:22:30.000Z","updated":"2022-10-12T01:23:11.911Z","comments":true,"path":"2020/10/13/vue中keep-alive缓存原理/","link":"","permalink":"http://example.com/2020/10/13/vue%E4%B8%ADkeep-alive%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/","excerpt":"","text":"Keep-alive 是什么1keep-alive`是`vue`中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染`DOM keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们 keep-alive可以设置以下props属性： include - 字符串或正则表达式。只有名称匹配的组件会被缓存 exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存 max - 数字。最多可以缓存多少组件实例 关于keep-alive的基本用法： 123&lt;keep-alive&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 使用includes和exclude： 12345678910111213&lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;&lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt;&lt;!-- 数组 (使用 `v-bind`) --&gt;&lt;keep-alive :include=&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;&lt;/keep-alive&gt; 匹配首先检查组件自身的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称 (父组件 components 选项的键值)，匿名组件不能被匹配 设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated与deactivated）： 首次进入组件时：beforeRouteEnter &gt; beforeCreate &gt; created&gt; mounted &gt; activated &gt; … … &gt; beforeRouteLeave &gt; deactivated 再次进入组件时：beforeRouteEnter &gt;activated &gt; … … &gt; beforeRouteLeave &gt; deactivated 使用场景使用原则：当我们在某些场景下不需要让页面重新加载时我们可以使用keepalive 举个栗子: 当我们从首页–&gt;列表页–&gt;商详页–&gt;再返回，这时候列表页应该是需要keep-alive 从首页–&gt;列表页–&gt;商详页–&gt;返回到列表页(需要缓存)–&gt;返回到首页(需要缓存)–&gt;再次进入列表页(不需要缓存)，这时候可以按需来控制页面的keep-alive 在路由中设置keepAlive属性判断是否需要缓存 1234567891011&#123; path: &#x27;list&#x27;, name: &#x27;itemList&#x27;, // 列表页 component (resolve) &#123; require([&#x27;@/pages/item/list&#x27;], resolve) &#125;, meta: &#123; keepAlive: true, title: &#x27;列表页&#x27; &#125;&#125; 使用&lt;keep-alive&gt; 12345678&lt;div id=&quot;app&quot; class=&#x27;wrapper&#x27;&gt; &lt;keep-alive&gt; &lt;!-- 需要缓存的视图组件 --&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;!-- 不需要缓存的视图组件 --&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/div&gt; 原理分析keep-alive是vue中内置的一个组件 源码位置：src&#x2F;core&#x2F;components&#x2F;keep-alive.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081export default &#123; name: &#x27;keep-alive&#x27;, abstract: true, props: &#123; include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] &#125;, created () &#123; this.cache = Object.create(null) this.keys = [] &#125;, destroyed () &#123; for (const key in this.cache) &#123; pruneCacheEntry(this.cache, key, this.keys) &#125; &#125;, mounted () &#123; this.$watch(&#x27;include&#x27;, val =&gt; &#123; pruneCache(this, name =&gt; matches(val, name)) &#125;) this.$watch(&#x27;exclude&#x27;, val =&gt; &#123; pruneCache(this, name =&gt; !matches(val, name)) &#125;) &#125;, render() &#123; /* 获取默认插槽中的第一个组件节点 */ const slot = this.$slots.default const vnode = getFirstComponentChild(slot) /* 获取该组件节点的componentOptions */ const componentOptions = vnode &amp;&amp; vnode.componentOptions if (componentOptions) &#123; /* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */ const name = getComponentName(componentOptions) const &#123; include, exclude &#125; = this /* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */ if ( (include &amp;&amp; (!name || !matches(include, name))) || // excluded (exclude &amp;&amp; name &amp;&amp; matches(exclude, name)) ) &#123; return vnode &#125; const &#123; cache, keys &#125; = this /* 获取组件的key值 */ const key = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;) : vnode.key /* 拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */ if (cache[key]) &#123; vnode.componentInstance = cache[key].componentInstance // make current key freshest remove(keys, key) keys.push(key) &#125; /* 如果没有命中缓存，则将其设置进缓存 */ else &#123; cache[key] = vnode keys.push(key) // prune oldest entry /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */ if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123; pruneCacheEntry(cache, keys[0], keys, this._vnode) &#125; &#125; vnode.data.keepAlive = true &#125; return vnode || (slot &amp;&amp; slot[0]) &#125;&#125; 可以看到该组件没有template，而是用了render，在组件渲染的时候会自动执行render函数 this.cache是一个对象，用来存储需要缓存的组件，它将以如下形式存储： 12345this.cache = &#123; &#x27;key1&#x27;:&#x27;组件1&#x27;, &#x27;key2&#x27;:&#x27;组件2&#x27;, // ...&#125; 在组件销毁的时候执行pruneCacheEntry函数 1234567891011121314function pruneCacheEntry ( cache: VNodeCache, key: string, keys: Array&lt;string&gt;, current?: VNode) &#123; const cached = cache[key] /* 判断当前没有处于被渲染状态的组件，将其销毁*/ if (cached &amp;&amp; (!current || cached.tag !== current.tag)) &#123; cached.componentInstance.$destroy() &#125; cache[key] = null remove(keys, key)&#125; 在mounted钩子函数中观测 include 和 exclude 的变化，如下： 12345678mounted () &#123; this.$watch(&#x27;include&#x27;, val =&gt; &#123; pruneCache(this, name =&gt; matches(val, name)) &#125;) this.$watch(&#x27;exclude&#x27;, val =&gt; &#123; pruneCache(this, name =&gt; !matches(val, name)) &#125;)&#125; 如果include 或exclude 发生了变化，即表示定义需要缓存的组件的规则或者不需要缓存的组件的规则发生了变化，那么就执行pruneCache函数，函数如下： 123456789101112function pruneCache (keepAliveInstance, filter) &#123; const &#123; cache, keys, _vnode &#125; = keepAliveInstance for (const key in cache) &#123; const cachedNode = cache[key] if (cachedNode) &#123; const name = getComponentName(cachedNode.componentOptions) if (name &amp;&amp; !filter(name)) &#123; pruneCacheEntry(cache, key, keys, _vnode) &#125; &#125; &#125;&#125; 在该函数内对this.cache对象进行遍历，取出每一项的name值，用其与新的缓存规则进行匹配，如果匹配不上，则表示在新的缓存规则下该组件已经不需要被缓存，则调用pruneCacheEntry函数将其从this.cache对象剔除即可 关于keep-alive的最强大缓存功能是在render函数中实现 首先获取组件的key值： 123const key = vnode.key == null? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;): vnode.key 拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存，如下： 1234567/* 如果命中缓存，则直接从缓存中拿 vnode 的组件实例 */if (cache[key]) &#123; vnode.componentInstance = cache[key].componentInstance /* 调整该组件key的顺序，将其从原来的地方删掉并重新放在最后一个 */ remove(keys, key) keys.push(key)&#125; 直接从缓存中拿 vnode 的组件实例，此时重新调整该组件key的顺序，将其从原来的地方删掉并重新放在this.keys中最后一个 this.cache对象中没有该key值的情况，如下： 123456789/* 如果没有命中缓存，则将其设置进缓存 */else &#123; cache[key] = vnode keys.push(key) /* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */ if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123; pruneCacheEntry(cache, keys[0], keys, this._vnode) &#125;&#125; 表明该组件还没有被缓存过，则以该组件的key为键，组件vnode为值，将其存入this.cache中，并且把key存入this.keys中 此时再判断this.keys中缓存组件的数量是否超过了设置的最大缓存数量值this.max，如果超过了，则把第一个缓存组件删掉 缓存后如何获取数据解决方案可以有以下两种： beforeRouteEnter actived beforeRouteEnter每次组件渲染的时候，都会执行beforeRouteEnter 1234567beforeRouteEnter(to, from, next)&#123; next(vm=&gt;&#123; console.log(vm) // 每次进入路由执行 vm.getData() // 获取数据 &#125;)&#125;, actived在keep-alive缓存的组件被激活的时候，都会执行actived钩子 123activated()&#123; this.getData() // 获取数据&#125;, 注意：服务器端渲染期间avtived不被调用","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"说说你对双向绑定的理解","slug":"说说你对双向绑定的理解","date":"2020-10-13T12:14:23.000Z","updated":"2022-10-12T01:13:11.255Z","comments":true,"path":"2020/10/13/说说你对双向绑定的理解/","link":"","permalink":"http://example.com/2020/10/13/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"什么是双向绑定我们先从单向绑定切入单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新双向绑定就很容易联想到了，在单向绑定的基础上，用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定举个栗子 当用户填写表单时，View的状态就被更新了，如果此时可以自动更新Model的状态，那就相当于我们把Model和View做了双向绑定关系图如下 双向绑定的原理是什么我们都知道 Vue 是数据双向绑定的框架，双向绑定由三个重要部分构成 数据层（Model）：应用的数据及业务逻辑 视图层（View）：应用的展示效果，各类UI组件 业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来 而上面的这个分层的架构方案，可以用一个专业术语进行称呼：MVVM这里的控制层的核心功能便是 “数据双向绑定” 。自然，我们只需弄懂它是什么，便可以进一步了解数据绑定的原理 理解ViewModel它的主要职责就是： 数据变化后更新视图 视图变化后更新数据 当然，它还有两个主要部分组成 监听器（Observer）：对所有数据的属性进行监听 解析器（Compiler）：对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数 实现双向绑定我们还是以Vue为例，先来看看Vue中的双向绑定流程是什么的 new Vue()首先执行初始化，对data执行响应化处理，这个过程发生Observe中 同时对模板执行编译，找到其中动态绑定的数据，从data中获取并初始化视图，这个过程发生在Compile中 同时定义⼀个更新函数和Watcher，将来对应数据变化时Watcher会调用更新函数 由于data的某个key在⼀个视图中可能出现多次，所以每个key都需要⼀个管家Dep来管理多个Watcher 将来data中数据⼀旦发生变化，会首先找到对应的Dep，通知所有Watcher执行更新函数 流程图如下： 实现先来一个构造函数：执行初始化，对data执行响应化处理 123456789101112131415class Vue &#123; constructor(options) &#123; this.$options = options; this.$data = options.data; // 对data选项做响应式处理 observe(this.$data); // 代理data到vm上 proxy(this); // 执行编译 new Compile(options.el, this); &#125; &#125; 对data选项执行响应化具体操作 123456789101112131415161718function observe(obj) &#123; if (typeof obj !== &quot;object&quot; || obj == null) &#123; return; &#125; new Observer(obj); &#125; class Observer &#123; constructor(value) &#123; this.value = value; this.walk(value); &#125; walk(obj) &#123; Object.keys(obj).forEach((key) =&gt; &#123; defineReactive(obj, key, obj[key]); &#125;); &#125; &#125; 编译Compile对每个元素节点的指令进行扫描跟解析,根据指令模板替换数据,以及绑定相应的更新函数 1234567891011121314151617181920212223242526272829class Compile &#123; constructor(el, vm) &#123; this.$vm = vm; this.$el = document.querySelector(el); // 获取dom if (this.$el) &#123; this.compile(this.$el); &#125; &#125; compile(el) &#123; const childNodes = el.childNodes; Array.from(childNodes).forEach((node) =&gt; &#123; // 遍历子元素 if (this.isElement(node)) &#123; // 判断是否为节点 console.log(&quot;编译元素&quot; + node.nodeName); &#125; else if (this.isInterpolation(node)) &#123; console.log(&quot;编译插值⽂本&quot; + node.textContent); // 判断是否为插值文本 &#123;&#123;&#125;&#125; &#125; if (node.childNodes &amp;&amp; node.childNodes.length &gt; 0) &#123; // 判断是否有子元素 this.compile(node); // 对子元素进行递归遍历 &#125; &#125;); &#125; isElement(node) &#123; return node.nodeType == 1; &#125; isInterpolation(node) &#123; return node.nodeType == 3 &amp;&amp; /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/.test(node.textContent); &#125; &#125; 依赖收集视图中会用到data中某key，这称为依赖。同⼀个key可能出现多次，每次都需要收集出来用⼀个Watcher来维护它们，此过程称为依赖收集多个Watcher需要⼀个Dep来管理，需要更新时由Dep统⼀通知 实现思路 defineReactive时为每⼀个key创建⼀个Dep实例 初始化视图时读取某个key，例如name1，创建⼀个watcher1 由于触发name1的getter方法，便将watcher1添加到name1对应的Dep中 当name1更新，setter触发时，便可通过对应Dep通知其管理所有Watcher更新 1234567891011121314151617181920// 负责更新视图 class Watcher &#123; constructor(vm, key, updater) &#123; this.vm = vm this.key = key this.updaterFn = updater // 创建实例时，把当前实例指定到Dep.target静态属性上 Dep.target = this // 读一下key，触发get vm[key] // 置空 Dep.target = null &#125; // 未来执行dom更新函数，由dep调用的 update() &#123; this.updaterFn.call(this.vm, this.vm[this.key]) &#125; &#125; 声明Dep 1234567891011class Dep &#123; constructor() &#123; this.deps = []; // 依赖管理 &#125; addDep(dep) &#123; this.deps.push(dep); &#125; notify() &#123; this.deps.forEach((dep) =&gt; dep.update()); &#125; &#125; 创建watcher时触发getter 12345678class Watcher &#123; constructor(vm, key, updateFn) &#123; Dep.target = this; this.vm[this.key]; Dep.target = null; &#125; &#125; 依赖收集，创建Dep实例 1234567891011121314function defineReactive(obj, key, val) &#123; this.observe(val); const dep = new Dep(); Object.defineProperty(obj, key, &#123; get() &#123; Dep.target &amp;&amp; dep.addDep(Dep.target);// Dep.target也就是Watcher实例 return val; &#125;, set(newVal) &#123; if (newVal === val) return; dep.notify(); // 通知dep执行更新方法 &#125;, &#125;); &#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"data为什么是一个函数不是一个对象","slug":"data为什么是一个函数不是一个对象","date":"2020-10-05T05:58:18.000Z","updated":"2022-10-05T06:47:54.985Z","comments":true,"path":"2020/10/05/data为什么是一个函数不是一个对象/","link":"","permalink":"http://example.com/2020/10/05/data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"实例和组件定义data的区别vue实例的时候定义data&#96;属性既可以是一个对象，也可以是一个函数 12345678910111213const app = new Vue(&#123; el:&quot;#app&quot;, // 对象格式 data:&#123; foo:&quot;foo&quot; &#125;, // 函数格式 data()&#123; return &#123; foo:&quot;foo&quot; &#125; &#125;&#125;) 组件中定义data属性，只能是一个函数 如果为组件data直接定义为一个对象 123456Vue.component(&#x27;component1&#x27;,&#123; template:`&lt;div&gt;组件&lt;/div&gt;`, data:&#123; foo:&quot;foo&quot; &#125;&#125;) 则会得到警告信息 警告说明：返回的data应该是一个函数在每一个组件实例中 组件data定义函数与对象的区别上面讲到组件data必须是一个函数，不知道大家有没有思考过这是为什么呢？ 在我们定义好一个组件的时候，vue最终都会通过Vue.extend()构成组件实例 这里我们模仿组件构造函数，定义data属性，采用对象的形式 123456function Component()&#123; &#125;Component.prototype.data = &#123; count : 0&#125; 创建两个组件实例 12const componentA = new Component()const componentB = new Component() 修改componentA组件data属性的值，componentB中的值也发生了改变 123console.log(componentB.data.count) // 0componentA.data.count = 1console.log(componentB.data.count) // 1 产生这样的原因这是两者共用了同一个内存地址，componentA修改的内容，同样对componentB产生了影响 如果我们采用函数的形式，则不会出现这种情况（函数返回的对象内存地址并不相同） 12345678function Component()&#123; this.data = this.data()&#125;Component.prototype.data = function ()&#123; return &#123; count : 0 &#125;&#125; 修改componentA组件data属性的值，componentB中的值不受影响 123console.log(componentB.data.count) // 0componentA.data.count = 1console.log(componentB.data.count) // 0 vue组件可能会有很多个实例，采用函数返回一个全新data形式，使每个实例对象的数据不会受到其他实例对象数据的污染 原理分析首先可以看看vue初始化data的代码，data的定义可以是函数也可以是对象 源码位置：/vue-dev/src/core/instance/state.js 1234567function initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125; ...&#125; data既能是object也能是function，那为什么还会出现上文警告呢？ 别急，继续看下文 组件在创建的时候，会进行选项的合并 源码位置：/vue-dev/src/core/util/options.js 自定义组件会进入mergeOptions进行选项合并 1234567891011121314151617Vue.prototype._init = function (options?: Object) &#123; ... // merge options if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; ... &#125; 定义data会进行数据校验 源码位置：/vue-dev/src/core/instance/init.js 这时候vm实例为undefined，进入if判断，若data类型不是function，则出现警告提示 123456789101112131415161718192021strats.data = function ( parentVal: any, childVal: any, vm?: Component): ?Function &#123; if (!vm) &#123; if (childVal &amp;&amp; typeof childVal !== &quot;function&quot;) &#123; process.env.NODE_ENV !== &quot;production&quot; &amp;&amp; warn( &#x27;The &quot;data&quot; option should be a function &#x27; + &quot;that returns a per-instance value in component &quot; + &quot;definitions.&quot;, vm ); return parentVal; &#125; return mergeDataOrFn(parentVal, childVal); &#125; return mergeDataOrFn(parentVal, childVal, vm);&#125;; 结论 根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况 组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue的两大核心","slug":"vue的两大核心","date":"2020-10-05T05:58:18.000Z","updated":"2022-10-05T06:49:32.815Z","comments":true,"path":"2020/10/05/vue的两大核心/","link":"","permalink":"http://example.com/2020/10/05/vue%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%A0%B8%E5%BF%83/","excerpt":"","text":"Vue核心特性数据驱动（MVVM)1MVVM`表示的是 `Model-View-ViewModel Model：模型层，负责处理业务逻辑以及和服务器端进行交互 View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面 ViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁 组件化1.什么是组件化一句话来说就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件2.组件化的优势 降低整个系统的耦合度，在保持接口不变的情况下，我们可以替换不同的组件快速完成需求，例如输入框，可以替换为日历、时间、范围等组件作具体的实现 调试方便，由于整个系统是通过组件组合起来的，在出现问题的时候，可以用排除法直接移除组件，或者根据报错的组件快速定位问题，之所以能够快速定位，是因为每个组件之间低耦合，职责单一，所以逻辑会比分析整个系统要简单 提高可维护性，由于每个组件的职责单一，并且组件在系统中是被复用的，所以对代码进行优化可获得系统的整体升级 指令系统解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM 常用的指令 条件渲染指令 v-if 列表渲染指令v-for 属性绑定指令v-bind 事件绑定指令v-on 双向数据绑定指令v-model","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue中的自定义指令以及应用场景","slug":"vue中的自定义指令以及应用场景","date":"2020-10-03T12:54:11.000Z","updated":"2022-10-12T01:08:50.856Z","comments":true,"path":"2020/10/03/vue中的自定义指令以及应用场景/","link":"","permalink":"http://example.com/2020/10/03/vue%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"什么是指令开始之前我们先学习一下指令系统这个词 指令系统是计算机硬件的语言系统，也叫机器语言，它是系统程序员看到的计算机的主要属性。因此指令系统表征了计算机的基本功能决定了机器所要求的能力 在vue中提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统 我们看到的v-开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令 指令使用的几种方式： 1234567891011121314//会实例化一个指令，但这个指令没有参数 `v-xxx`// -- 将值传到指令中`v-xxx=&quot;value&quot;` // -- 将字符串传入到指令中，如`v-html=&quot;&#x27;&lt;p&gt;内容&lt;/p&gt;&#x27;&quot;``v-xxx=&quot;&#x27;string&#x27;&quot;` // -- 传参数（`arg`），如`v-bind:class=&quot;className&quot;``v-xxx:arg=&quot;value&quot;` // -- 使用修饰符（`modifier`）`v-xxx:arg.modifier=&quot;value&quot;` 如何实现注册一个自定义指令有全局注册与局部注册 全局注册主要是通过Vue.directive方法进行注册 Vue.directive第一个参数是指令的名字（不需要写上v-前缀），第二个参数可以是对象数据，也可以是一个指令函数 12345678// 注册一个全局自定义指令 `v-focus`Vue.directive(&#x27;focus&#x27;, &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能 &#125;&#125;) 局部注册通过在组件options选项中设置directive属性 12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能 &#125; &#125;&#125; 然后你可以在模板中任何元素上使用新的 v-focus property，如下： 1&lt;input v-focus /&gt; 1 自定义指令也像组件那样存在钩子函数： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中) update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用 unbind：只调用一次，指令与元素解绑时调用 所有的钩子函数的参数都有以下： el：指令所绑定的元素，可以用来直接操作 DOM &#96;&#96;&#96;binding 12345：一个对象，包含以下 property 1234567891011121314151617181920212223242526 ： - `name`：指令名，不包括 `v-` 前缀。 - `value`：指令的绑定值，例如：`v-my-directive=&quot;1 + 1&quot;` 中，绑定值为 `2`。 - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。 - `expression`：字符串形式的指令表达式。例如 `v-my-directive=&quot;1 + 1&quot;` 中，表达式为 `&quot;1 + 1&quot;`。 - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `&quot;foo&quot;`。 - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `&#123; foo: true, bar: true &#125;`- `vnode`：`Vue` 编译生成的虚拟节点- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用&gt; 除了 `el` 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 `dataset` 来进行举个例子：```html&lt;div v-demo=&quot;&#123; color: &#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;script&gt; Vue.directive(&#x27;demo&#x27;, function (el, binding) &#123; console.log(binding.value.color) // &quot;white&quot; console.log(binding.value.text) // &quot;hello!&quot; &#125;)&lt;/script&gt; 应用场景使用自定义指令可以满足我们日常一些场景，这里给出几个自定义指令的案例： 表单防止重复提交 图片懒加载 一键 Copy的功能 表单防止重复提交表单防止重复提交这种情况设置一个v-throttle自定义指令来实现 举个例子： 123456789101112131415161718192021// 1.设置v-throttle自定义指令Vue.directive(&#x27;throttle&#x27;, &#123; bind: (el, binding) =&gt; &#123; let throttleTime = binding.value; // 节流时间 if (!throttleTime) &#123; // 用户若不设置节流时间，则默认2s throttleTime = 2000; &#125; let cbFun; el.addEventListener(&#x27;click&#x27;, event =&gt; &#123; if (!cbFun) &#123; // 第一次执行 cbFun = setTimeout(() =&gt; &#123; cbFun = null; &#125;, throttleTime); &#125; else &#123; event &amp;&amp; event.stopImmediatePropagation(); &#125; &#125;, true); &#125;,&#125;);// 2.为button标签设置v-throttle自定义指令&lt;button @click=&quot;sayHello&quot; v-throttle&gt;提交&lt;/button&gt; 图片懒加载设置一个v-lazy自定义指令完成图片懒加载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const LazyLoad = &#123; // install方法 install(Vue,options)&#123; // 代替图片的loading图 let defaultSrc = options.default; Vue.directive(&#x27;lazy&#x27;,&#123; bind(el,binding)&#123; LazyLoad.init(el,binding.value,defaultSrc); &#125;, inserted(el)&#123; // 兼容处理 if(&#x27;IntersectionObserver&#x27; in window)&#123; LazyLoad.observe(el); &#125;else&#123; LazyLoad.listenerScroll(el); &#125; &#125;, &#125;) &#125;, // 初始化 init(el,val,def)&#123; // data-src 储存真实src el.setAttribute(&#x27;data-src&#x27;,val); // 设置src为loading图 el.setAttribute(&#x27;src&#x27;,def); &#125;, // 利用IntersectionObserver监听el observe(el)&#123; let io = new IntersectionObserver(entries =&gt; &#123; let realSrc = el.dataset.src; if(entries[0].isIntersecting)&#123; if(realSrc)&#123; el.src = realSrc; el.removeAttribute(&#x27;data-src&#x27;); &#125; &#125; &#125;); io.observe(el); &#125;, // 监听scroll事件 listenerScroll(el)&#123; let handler = LazyLoad.throttle(LazyLoad.load,300); LazyLoad.load(el); window.addEventListener(&#x27;scroll&#x27;,() =&gt; &#123; handler(el); &#125;); &#125;, // 加载真实图片 load(el)&#123; let windowHeight = document.documentElement.clientHeight let elTop = el.getBoundingClientRect().top; let elBtm = el.getBoundingClientRect().bottom; let realSrc = el.dataset.src; if(elTop - windowHeight&lt;0&amp;&amp;elBtm &gt; 0)&#123; if(realSrc)&#123; el.src = realSrc; el.removeAttribute(&#x27;data-src&#x27;); &#125; &#125; &#125;, // 节流 throttle(fn,delay)&#123; let timer; let prevTime; return function(...args)&#123; let currTime = Date.now(); let context = this; if(!prevTime) prevTime = currTime; clearTimeout(timer); if(currTime - prevTime &gt; delay)&#123; prevTime = currTime; fn.apply(context,args); clearTimeout(timer); return; &#125; timer = setTimeout(function()&#123; prevTime = Date.now(); timer = null; fn.apply(context,args); &#125;,delay); &#125; &#125;&#125;export default LazyLoad; 一键 Copy的功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import &#123; Message &#125; from &#x27;ant-design-vue&#x27;;const vCopy = &#123; // /* bind 钩子函数，第一次绑定时调用，可以在这里做初始化设置 el: 作用的 dom 对象 value: 传给指令的值，也就是我们要 copy 的值 */ bind(el, &#123; value &#125;) &#123; el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到 el.handler = () =&gt; &#123; if (!el.$value) &#123; // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意 Message.warning(&#x27;无复制内容&#x27;); return; &#125; // 动态创建 textarea 标签 const textarea = document.createElement(&#x27;textarea&#x27;); // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域 textarea.readOnly = &#x27;readonly&#x27;; textarea.style.position = &#x27;absolute&#x27;; textarea.style.left = &#x27;-9999px&#x27;; // 将要 copy 的值赋给 textarea 标签的 value 属性 textarea.value = el.$value; // 将 textarea 插入到 body 中 document.body.appendChild(textarea); // 选中值并复制 textarea.select(); // textarea.setSelectionRange(0, textarea.value.length); const result = document.execCommand(&#x27;Copy&#x27;); if (result) &#123; Message.success(&#x27;复制成功&#x27;); &#125; document.body.removeChild(textarea); &#125;; // 绑定点击事件，就是所谓的一键 copy 啦 el.addEventListener(&#x27;click&#x27;, el.handler); &#125;, // 当传进来的值更新的时候触发 componentUpdated(el, &#123; value &#125;) &#123; el.$value = value; &#125;, // 指令与元素解绑的时候，移除事件绑定 unbind(el) &#123; el.removeEventListener(&#x27;click&#x27;, el.handler); &#125;,&#125;;export default vCopy; 关于自定义指令还有很多应用场景，如：拖拽指令、页面水印、权限校验等等应用场景","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue中slot使用","slug":"vue中slot使用","date":"2020-10-02T17:05:01.000Z","updated":"2022-10-12T01:07:05.338Z","comments":true,"path":"2020/10/03/vue中slot使用/","link":"","permalink":"http://example.com/2020/10/03/vue%E4%B8%ADslot%E4%BD%BF%E7%94%A8/","excerpt":"","text":"slot是什么在HTML中 slot 元素 ，作为 Web Components 技术套件的一部分，是Web组件内的一个占位符 该占位符可以在后期使用自己的标记语言填充 举个栗子 123456789&lt;template id=&quot;element-details-template&quot;&gt; &lt;slot name=&quot;element-name&quot;&gt;Slot template&lt;/slot&gt;&lt;/template&gt;&lt;element-details&gt; &lt;span slot=&quot;element-name&quot;&gt;1&lt;/span&gt;&lt;/element-details&gt;&lt;element-details&gt; &lt;span slot=&quot;element-name&quot;&gt;2&lt;/span&gt;&lt;/element-details&gt; template不会展示到页面中，需要用先获取它的引用，然后添加到DOM中， 1234567891011customElements.define(&#x27;element-details&#x27;, class extends HTMLElement &#123; constructor() &#123; super(); const template = document .getElementById(&#x27;element-details-template&#x27;) .content; const shadowRoot = this.attachShadow(&#123;mode: &#x27;open&#x27;&#125;) .appendChild(template.cloneNode(true)); &#125;&#125;) 在Vue中的概念也是如此 Slot 艺名插槽，花名“占坑”，我们可以理解为solt在组件模板中占好了位置，当使用该组件标签时候，组件标签里面的内容就会自动填坑（替换组件模板中slot位置），作为承载分发内容的出口 可以将其类比为插卡式的FC游戏机，游戏机暴露卡槽（插槽）让用户插入不同的游戏磁条（自定义内容） 放张图感受一下 使用场景通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理 如果父组件在使用到一个复用组件的时候，获取这个组件在不同的地方有少量的更改，如果去重写组件是一件不明智的事情 通过slot插槽向组件内部指定位置传递内容，完成这个复用组件在不同场景的应用 比如布局组件、表格列、下拉选、弹框显示内容等 分类slot可以分来以下三种： 默认插槽 具名插槽 作用域插槽 默认插槽子组件用&lt;slot&gt;标签来确定渲染的位置，标签里面可以放DOM结构，当父组件使用的时候没有往插槽传入内容，标签内DOM结构就会显示在页面 父组件在使用的时候，直接在子组件的标签内写入内容即可 子组件Child.vue 12345&lt;template&gt; &lt;slot&gt; &lt;p&gt;插槽后备的内容&lt;/p&gt; &lt;/slot&gt;&lt;/template&gt; 父组件 123&lt;Child&gt; &lt;div&gt;默认插槽&lt;/div&gt; &lt;/Child&gt; 具名插槽子组件用name属性来表示插槽的名字，不传为默认插槽 父组件中在使用时在默认插槽的基础上加上slot属性，值为子组件插槽name属性值 子组件Child.vue 1234&lt;template&gt; &lt;slot&gt;插槽后备的内容&lt;/slot&gt; &lt;slot name=&quot;content&quot;&gt;插槽后备的内容&lt;/slot&gt;&lt;/template&gt; 父组件 12345&lt;child&gt; &lt;template v-slot:default&gt;具名插槽&lt;/template&gt; &lt;!-- 具名插槽⽤插槽名做参数 --&gt; &lt;template v-slot:content&gt;内容...&lt;/template&gt;&lt;/child&gt; 作用域插槽子组件在作用域上绑定属性来将子组件的信息传给父组件使用，这些属性会被挂在父组件v-slot接受的对象上 父组件中在使用时通过v-slot:（简写：#）获取子组件的信息，在内容中使用 子组件Child.vue 12345&lt;template&gt; &lt;slot name=&quot;footer&quot; testProps=&quot;子组件的值&quot;&gt; &lt;h3&gt;没传footer插槽&lt;/h3&gt; &lt;/slot&gt;&lt;/template&gt; 父组件 123456789&lt;child&gt; &lt;!-- 把v-slot的值指定为作⽤域上下⽂对象 --&gt; &lt;template v-slot:default=&quot;slotProps&quot;&gt; 来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125; &lt;/template&gt; &lt;template #default=&quot;slotProps&quot;&gt; 来⾃⼦组件数据：&#123;&#123;slotProps.testProps&#125;&#125; &lt;/template&gt;&lt;/child&gt; 小结： v-slot属性只能在&lt;template&gt;上使用，但在只有默认插槽时可以在组件标签上使用 默认插槽名为default，可以省略default直接写v-slot 缩写为#时不能不写参数，写成#default 可以通过解构获取v-slot=&#123;user&#125;，还可以重命名v-slot=&quot;&#123;user: newName&#125;&quot;和定义默认值v-slot=&quot;&#123;user = &#39;默认值&#39;&#125;&quot; 原理分析slot本质上是返回VNode的函数，一般情况下，Vue中的组件要渲染到页面上需要经过template -&gt; render function -&gt; VNode -&gt; DOM 过程，这里看看slot如何实现： 编写一个buttonCounter组件，使用匿名插槽 123Vue.component(&#x27;button-counter&#x27;, &#123; template: &#x27;&lt;div&gt; &lt;slot&gt;我是默认内容&lt;/slot&gt;&lt;/div&gt;&#x27;&#125;) 使用该组件 12345new Vue(&#123; el: &#x27;#app&#x27;, template: &#x27;&lt;button-counter&gt;&lt;span&gt;我是slot传入内容&lt;/span&gt;&lt;/button-counter&gt;&#x27;, components:&#123;buttonCounter&#125;&#125;) 获取buttonCounter组件渲染函数 1234(function anonymous() &#123;with(this)&#123;return _c(&#x27;div&#x27;,[_t(&quot;default&quot;,[_v(&quot;我是默认内容&quot;)])],2)&#125;&#125;) _v表示穿件普通文本节点，_t表示渲染插槽的函数 渲染插槽函数renderSlot（做了简化） 1234567891011121314function renderSlot ( name, fallback, props, bindObject) &#123; // 得到渲染插槽内容的函数 var scopedSlotFn = this.$scopedSlots[name]; var nodes; // 如果存在插槽渲染函数，则执行插槽渲染函数，生成nodes节点返回 // 否则使用默认值 nodes = scopedSlotFn(props) || fallback; return nodes;&#125; name属性表示定义插槽的名字，默认值为default，fallback表示子组件中的slot节点的默认值 关于this.$scopredSlots是什么，我们可以先看看vm.slot 12345function initRender (vm) &#123; ... vm.$slots = resolveSlots(options._renderChildren, renderContext); ...&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243resolveSlots`函数会对`children`节点做归类和过滤处理，返回`slotsfunction resolveSlots ( children, context ) &#123; if (!children || !children.length) &#123; return &#123;&#125; &#125; var slots = &#123;&#125;; for (var i = 0, l = children.length; i &lt; l; i++) &#123; var child = children[i]; var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node if (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) &#123; delete data.attrs.slot; &#125; // named slots should only be respected if the vnode was rendered in the // same context. if ((child.context === context || child.fnContext === context) &amp;&amp; data &amp;&amp; data.slot != null ) &#123; // 如果slot存在(slot=&quot;header&quot;) 则拿对应的值作为key var name = data.slot; var slot = (slots[name] || (slots[name] = [])); // 如果是tempalte元素 则把template的children添加进数组中，这也就是为什么你写的template标签并不会渲染成另一个标签到页面 if (child.tag === &#x27;template&#x27;) &#123; slot.push.apply(slot, child.children || []); &#125; else &#123; slot.push(child); &#125; &#125; else &#123; // 如果没有就默认是default (slots.default || (slots.default = [])).push(child); &#125; &#125; // ignore slots that contains only whitespace for (var name$1 in slots) &#123; if (slots[name$1].every(isWhitespace)) &#123; delete slots[name$1]; &#125; &#125; return slots&#125; 123456_render`渲染函数通过`normalizeScopedSlots`得到`vm.$scopedSlotsvm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots); 作用域插槽中父组件能够得到子组件的值是因为在renderSlot的时候执行会传入props，也就是上述_t第三个参数，父组件则能够得到子组件传递过来的值","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue中的key的原理","slug":"vue中key原理解析","date":"2020-10-02T15:58:18.000Z","updated":"2022-10-12T01:04:24.577Z","comments":true,"path":"2020/10/02/vue中key原理解析/","link":"","permalink":"http://example.com/2020/10/02/vue%E4%B8%ADkey%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"","text":"Key是什么开始之前，我们先还原两个实际工作场景 当我们在使用v-for时，需要给单元加上key 123&lt;ul&gt; &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt;&lt;/ul&gt; 2.用+new Date()生成的时间戳作为key，手动强制触发重新渲染 1&lt;Comp :key=&quot;+new Date()&quot; /&gt; 那么这背后的逻辑是什么，key的作用又是什么？ 一句话来讲 key是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点 场景背后的逻辑当我们在使用v-for时，需要给单元加上key 如果不用key，Vue会采用就地复地原则：最小化element的移动，并且会尝试尽最大程度在同适当的地方对相同类型的element，做patch或者reuse。 如果使用了key，Vue会根据keys的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed 用+new Date()生成的时间戳作为key，手动强制触发重新渲染 当拥有新值的rerender作为key时，拥有了新key的Comp出现了，那么旧key Comp会被移除，新key Comp触发渲染 设置key与不设置key区别举个例子： 创建一个实例，2秒后往items数组插入数据 123456789101112131415161718&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;p v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;../../dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 创建实例 const app = new Vue(&#123; el: &#x27;#demo&#x27;, data: &#123; items: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;] &#125;, mounted () &#123; setTimeout(() =&gt; &#123; this.items.splice(2, 0, &#x27;f&#x27;) // &#125;, 2000); &#125;, &#125;); &lt;/script&gt;&lt;/body&gt; 在不使用key的情况，vue会进行这样的操作： 分析下整体流程： 比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较C，F，相同类型的节点，进行patch，数据不同，发生dom操作 比较D，C，相同类型的节点，进行patch，数据不同，发生dom操作 比较E，D，相同类型的节点，进行patch，数据不同，发生dom操作 循环结束，将E插入到DOM中 一共发生了3次更新，1次插入操作 在使用key的情况：vue会进行这样的操作： 比较A，A，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较B，B，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较C，F，不相同类型的节点 比较E、E，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较D、D，相同类型的节点，进行patch，但数据相同，不发生dom操作 比较C、C，相同类型的节点，进行patch，但数据相同，不发生dom操作 循环结束，将F插入到C之前 一共发生了0次更新，1次插入操作 通过上面两个小例子，可见设置key能够大大减少对页面的DOM操作，提高了diff效率 #设置key值一定能提高diff效率吗？其实不然，文档中也明确表示 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素 这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出 建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升 原理分析源码位置：core&#x2F;vdom&#x2F;patch.js 这里判断是否为同一个key，首先判断的是key值是否相等如果没有设置key，那么key为undefined，这时候undefined是恒等于undefined 12345678910111213141516function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; ( ( a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error) ) ) )&#125; 123456789101112131415161718192021222324252627282930313233343536373839updateChildren`方法中会对新旧`vnode`进行`diff`，然后将比对出的结果用来更新真实的`DOMfunction updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; ... while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (isUndef(oldStartVnode)) &#123; ... &#125; else if (isUndef(oldEndVnode)) &#123; ... &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; ... &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; ... &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right ... &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left ... &#125; else &#123; if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) if (isUndef(idxInOld)) &#123; // New element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; else &#123; vnodeToMove = oldCh[idxInOld] if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; ...&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue的常用修饰符","slug":"vue的常用修饰符","date":"2020-09-06T03:20:24.000Z","updated":"2022-10-05T06:49:25.990Z","comments":true,"path":"2020/09/06/vue的常用修饰符/","link":"","permalink":"http://example.com/2020/09/06/vue%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"","text":"修饰符是什么在程序世界里，修饰符是用于限定类型以及类型成员的声明的一种符号 在Vue中，修饰符处理了许多DOM事件的细节，让我们不再需要花大量的时间去处理这些烦恼的事情，而能有更多的精力专注于程序的逻辑处理 vue中修饰符分为以下五种： 表单修饰符 事件修饰符 鼠标按键修饰符 键值修饰符 v-bind修饰符 修饰符的作用表单修饰符在我们填写表单的时候用得最多的是input标签，指令用得最多的是v-model 关于表单的修饰符有如下： lazy trim number lazy在我们填完信息，光标离开标签的时候，才会将值赋予给value，也就是在change事件之后再进行信息同步 12&lt;input type=&quot;text&quot; v-model.lazy=&quot;value&quot;&gt;&lt;p&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; trim自动过滤用户输入的首空格字符，而中间的空格不会过滤 1&lt;input type=&quot;text&quot; v-model.trim=&quot;value&quot;&gt; number自动将用户的输入值转为数值类型，但如果这个值无法被parseFloat解析，则会返回原来的值 1&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt; 事件修饰符事件修饰符是对事件捕获以及目标进行了处理，有如下修饰符： stop prevent self once capture passive native stop阻止了事件冒泡，相当于调用了event.stopPropagation方法 1234&lt;div @click=&quot;shout(2)&quot;&gt; &lt;button @click.stop=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;/div&gt;//只输出1 prevent阻止了事件的默认行为，相当于调用了event.preventDefault方法 1&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; self只当在 event.target 是当前元素自身时触发处理函数 1&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击 once绑定了事件以后只能触发一次，第二次就不会触发 1&lt;button @click.once=&quot;shout(1)&quot;&gt;ok&lt;/button&gt; capture使事件触发从包含这个元素的顶层开始往下触发 12345678910111213&lt;div @click.capture=&quot;shout(1)&quot;&gt; obj1&lt;div @click.capture=&quot;shout(2)&quot;&gt; obj2&lt;div @click=&quot;shout(3)&quot;&gt; obj3&lt;div @click=&quot;shout(4)&quot;&gt; obj4&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;// 输出结构: 1 2 4 3 passive在移动端，当我们在监听元素滚动事件的时候，会一直触发onscroll事件会让我们的网页变卡，因此我们使用这个修饰符的时候，相当于给onscroll事件整了一个.lazy修饰符 1234&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成 --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;&lt;div v-on:scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt; 不要把 .passive 和 .prevent 一起使用,因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。 passive 会告诉浏览器你不想阻止事件的默认行为 native让组件变成像html内置标签那样监听根元素的原生事件，否则组件上使用 v-on 只会监听自定义事件 1&lt;my-component v-on:click.native=&quot;doSomething&quot;&gt;&lt;/my-component&gt; 使用.native修饰符来操作普通HTML标签是会令事件失效的 鼠标按钮修饰符鼠标按钮修饰符针对的就是左键、右键、中键点击，有如下： left 左键点击 right 右键点击 middle 中键点击 123&lt;button @click.left=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;button @click.right=&quot;shout(1)&quot;&gt;ok&lt;/button&gt;&lt;button @click.middle=&quot;shout(1)&quot;&gt;ok&lt;/button&gt; 键盘修饰符键盘修饰符是用来修饰键盘事件（onkeyup，onkeydown）的，有如下： keyCode存在很多，但vue为我们提供了别名，分为以下两种： 普通键（enter、tab、delete、space、esc、up…） 系统修饰键（ctrl、alt、meta、shift…） 12// 只有按键为keyCode的时候才触发&lt;input type=&quot;text&quot; @keyup.keyCode=&quot;shout()&quot;&gt; 还可以通过以下方式自定义一些全局的键盘码别名 1Vue.config.keyCodes.f2 = 113 v-bind修饰符v-bind修饰符主要是为属性进行操作，用来分别有如下： async prop camel async能对props进行一个双向绑定 1234//父组件&lt;comp :myMessage.sync=&quot;bar&quot;&gt;&lt;/comp&gt; //子组件this.$emit(&#x27;update:myMessage&#x27;,params); 以上这种方法相当于以下的简写 123456789//父亲组件&lt;comp :myMessage=&quot;bar&quot; @update:myMessage=&quot;func&quot;&gt;&lt;/comp&gt;func(e)&#123; this.bar = e;&#125;//子组件jsfunc2()&#123; this.$emit(&#x27;update:myMessage&#x27;,params);&#125; 使用async需要注意以下两点： 使用sync的时候，子组件传递的事件名格式必须为update:value，其中value必须与子组件中props中声明的名称完全一致 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”&#123; title: doc.title &#125;”，是无法正常工作的 props设置自定义标签属性，避免暴露数据，防止污染HTML结构 1&lt;input id=&quot;uid&quot; title=&quot;title1&quot; value=&quot;1&quot; :index.prop=&quot;index&quot;&gt; 1 camel将命名变为驼峰命名法，如将view-Box属性名转换为 viewBox 1&lt;svg :viewBox=&quot;viewBox&quot;&gt;&lt;/svg&gt; 1 三、应用场景根据每一个修饰符的功能，我们可以得到以下修饰符的应用场景： .stop：阻止事件冒泡 .native：绑定原生事件 .once：事件只执行一次 .self ：将事件绑定在自身身上，相当于阻止事件冒泡 .prevent：阻止默认事件 .caption：用于事件捕获 .once：只触发一次 .keyCode：监听特定键盘按下 .right：右键","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue的实例挂载过程","slug":"vue的实例挂载过程","date":"2020-09-06T03:20:24.000Z","updated":"2022-10-05T06:49:40.163Z","comments":true,"path":"2020/09/06/vue的实例挂载过程/","link":"","permalink":"http://example.com/2020/09/06/vue%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"分析首先找到vue的构造函数 源码位置：src\\core\\instance\\index.js 12345678function Vue (options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125; options是用户传递过来的配置项，如data、methods等常用的方法 vue构建函数调用_init方法，但我们发现本文件中并没有此方法，但仔细可以看到文件下方定定义了很多初始化方法 12345initMixin(Vue); // 定义 _initstateMixin(Vue); // 定义 $set $get $delete $watch 等eventsMixin(Vue); // 定义事件 $on $once $off $emitlifecycleMixin(Vue);// 定义 _update $forceUpdate $destroyrenderMixin(Vue); // 定义 _render 返回虚拟dom 首先可以看initMixin方法，发现该方法在Vue原型上定义了_init方法 源码位置：src\\core\\instance\\init.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this // a uid vm._uid = uid++ let startTag, endTag /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag) &#125; // a flag to avoid this being observed vm._isVue = true // merge options // 合并属性，判断初始化的是否是组件，这里合并主要是 mixins 或 extends 的方法 if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) &#125; else &#123; // 合并vue属性 vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; // 初始化proxy拦截器 initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self vm._self = vm // 初始化组件生命周期标志位 initLifecycle(vm) // 初始化组件事件侦听 initEvents(vm) // 初始化渲染方法 initRender(vm) callHook(vm, &#x27;beforeCreate&#x27;) // 初始化依赖注入内容，在初始化data、props之前 initInjections(vm) // resolve injections before data/props // 初始化props/data/method/watch/methods initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, &#x27;created&#x27;) /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; // 挂载元素 if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125; 仔细阅读上面的代码，我们得到以下结论： 在调用beforeCreate之前，数据初始化并未完成，像data、props这些属性无法访问到 到了created的时候，数据已经初始化完成，能够访问data、props这些属性，但这时候并未完成dom的挂载，因此无法访问到dom元素 挂载方法是调用vm.$mount方法 initState方法是完成props/data/method/watch/methods的初始化 源码位置：src\\core\\instance\\state.js 12345678910111213141516171819export function initState (vm: Component) &#123; // 初始化组件的watcher列表 vm._watchers = [] const opts = vm.$options // 初始化props if (opts.props) initProps(vm, opts.props) // 初始化methods方法 if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; // 初始化data initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 我们和这里主要看初始化data的方法为initData，它与initState在同一文件上 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function initData (vm: Component) &#123; let data = vm.$options.data // 获取到组件上的data data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( &#x27;data functions should return an object:\\n&#x27; + &#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;, vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; // 属性名不能与方法名重复 if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`, vm ) &#125; &#125; // 属性名不能与state名称重复 if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( `The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; // 验证key值的合法性 // 将_data中的数据挂载到组件vm上,这样就可以通过this.xxx访问到组件上的数据 proxy(vm, `_data`, key) &#125; &#125; // observe data // 响应式监听data是数据的变化 observe(data, true /* asRootData */)&#125; 仔细阅读上面的代码，我们可以得到以下结论： 初始化顺序：props、methods、data data定义的时候可选择函数形式或者对象形式（组件只能为函数形式） 关于数据响应式在这就不展开详细说明 上文提到挂载方法是调用vm.$mount方法 源码位置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; // 获取或查询元素 el = el &amp;&amp; query(el) /* istanbul ignore if */ // vue 不允许直接挂载到body或页面文档上 if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125; const options = this.$options // resolve template/el and convert to render function if (!options.render) &#123; let template = options.template // 存在template模板，解析vue模板文件 if (template) &#123; if (typeof template === &#x27;string&#x27;) &#123; if (template.charAt(0) === &#x27;#&#x27;) &#123; template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !template) &#123; warn( `Template element not found or is empty: $&#123;options.template&#125;`, this ) &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(&#x27;invalid template option:&#x27; + template, this) &#125; return this &#125; &#125; else if (el) &#123; // 通过选择器获取元素内容 template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile&#x27;) &#125; /** * 1.将temmplate解析ast tree * 2.将ast tree转换成render语法字符串 * 3.生成render方法 */ const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; outputSourceRange: process.env.NODE_ENV !== &#x27;production&#x27;, shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile end&#x27;) measure(`vue $&#123;this._name&#125; compile`, &#x27;compile&#x27;, &#x27;compile end&#x27;) &#125; &#125; &#125; return mount.call(this, el, hydrating)&#125; 阅读上面代码，我们能得到以下结论： 不要将根元素放到body或者html上 可以在对象中定义template/render或者直接使用template、el表示元素选择器 最终都会解析成render函数，调用compileToFunctions，会将template解析成render函数 对template的解析步骤大致分为以下几步： 将html文档片段解析成ast描述符 将ast描述符解析成字符串 生成render函数 生成render函数，挂载到vm上后，会再次调用mount方法 源码位置：src\\platforms\\web\\runtime\\index.js 123456789// public mount methodVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined // 渲染组件 return mountComponent(this, el, hydrating)&#125; 调用mountComponent渲染组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el // 如果没有获取解析的render函数，则会抛出警告 // render是解析模板文件生成的 if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#x27;#&#x27;) || vm.$options.el || el) &#123; warn( &#x27;You are using the runtime-only build of Vue where the template &#x27; + &#x27;compiler is not available. Either pre-compile the templates into &#x27; + &#x27;render functions, or use the compiler-included build.&#x27;, vm ) &#125; else &#123; // 没有获取到vue的模板文件 warn( &#x27;Failed to mount component: template or render function not defined.&#x27;, vm ) &#125; &#125; &#125; // 执行beforeMount钩子 callHook(vm, &#x27;beforeMount&#x27;) let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; const name = vm._name const id = vm._uid const startTag = `vue-perf-start:$&#123;id&#125;` const endTag = `vue-perf-end:$&#123;id&#125;` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue $&#123;name&#125; render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue $&#123;name&#125; patch`, startTag, endTag) &#125; &#125; else &#123; // 定义更新函数 updateComponent = () =&gt; &#123; // 实际调⽤是在lifeCycleMixin中定义的_update和renderMixin中定义的_render vm._update(vm._render(), hydrating) &#125; &#125; // we set this to vm._watcher inside the watcher&#x27;s constructor // since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child // component&#x27;s mounted hook), which relies on vm._watcher being already defined // 监听当前组件状态，当有数据变化时，更新组件 new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; // 数据更新引发的组件更新 callHook(vm, &#x27;beforeUpdate&#x27;) &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, &#x27;mounted&#x27;) &#125; return vm&#125; 阅读上面代码，我们得到以下结论： 会触发beforeCreate钩子 定义updateComponent渲染页面视图的方法 监听组件数据，一旦发生变化，触发beforeUpdate生命钩子 updateComponent方法主要执行在vue初始化时声明的render，update方法 1render`的作用主要是生成`vnode 源码位置：src\\core\\instance\\render.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 定义vue 原型上的render方法Vue.prototype._render = function (): VNode &#123; const vm: Component = this // render函数来自于组件的option const &#123; render, _parentVnode &#125; = vm.$options if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots ) &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try &#123; // There&#x27;s no need to maintain a stack because all render fns are called // separately from one another. Nested component&#x27;s render fns are called // when parent component is patched. currentRenderingInstance = vm // 调用render方法，自己的独特的render方法， 传入createElement参数，生成vNode vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; finally &#123; currentRenderingInstance = null &#125; // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; Array.isArray(vnode)) &#123; warn( &#x27;Multiple root nodes returned from render function. Render function &#x27; + &#x27;should return a single root node.&#x27;, vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode&#125; _update主要功能是调用patch，将vnode转换为真实DOM，并且更新到页面中 源码位置：src\\core\\instance\\lifecycle.js 1234567891011121314151617181920212223242526272829303132Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode // 设置当前激活的作用域 const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; // initial render // 执行具体的挂载逻辑 vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent&#x27;s updated hook. &#125; 结论 new Vue的时候调用会调用_init方法 定义 $set、$get 、$delete、$watch 等方法 定义 $on、$off、$emit、$off等事件 定义 _update、$forceUpdate、$destroy生命周期 调用$mount进行页面的挂载 挂载的时候主要是通过mountComponent方法 定义updateComponent更新函数 执行render生成虚拟DOM _update将虚拟DOM生成真实DOM结构，并且渲染到页面中","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue的diff算法","slug":"vue的diff算法","date":"2020-08-10T06:30:42.000Z","updated":"2022-10-05T06:49:19.250Z","comments":true,"path":"2020/08/10/vue的diff算法/","link":"","permalink":"http://example.com/2020/08/10/vue%E7%9A%84diff%E7%AE%97%E6%B3%95/","excerpt":"","text":"diff算法是什么diff 算法是一种通过同层的树节点进行比较的高效算法 其有两个特点： 比较只会在同层级进行, 不会跨层级比较 在diff比较的过程中，循环从两边向中间比较 diff 算法在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较 比较方式diff整体策略为：深度优先，同层比较 比较只会在同层级进行, 不会跨层级比较 下面举个vue通过diff算法更新的例子： 新旧VNode节点如下图所示： 第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为diff后的第一个真实节点，同时旧节点endIndex移动到C，新节点的 startIndex 移动到了 C 第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，同理，diff 后创建了 C 的真实节点插入到第一次创建的 D 节点后面。同时旧节点的 endIndex 移动到了 B，新节点的 startIndex 移动到了 E 第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。同时新节点的 startIndex 移动到了 A。旧节点的 startIndex 和 endIndex 都保持不动 第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 diff 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。同时旧节点的 startIndex 移动到了 B，新节点的startIndex 移动到了 B 第五次循环中，情形同第四次循环一样，因此 diff 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。同时旧节点的 startIndex移动到了 C，新节点的 startIndex 移动到了 F 新节点的 startIndex 已经大于 endIndex 了，需要创建 newStartIdx 和 newEndIdx 之间的所有节点，也就是节点F，直接创建 F 节点对应的真实节点放到 B 节点后面 原理分析当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图 源码位置：src&#x2F;core&#x2F;vdom&#x2F;patch.js 12345678910111213141516171819202122232425262728293031323334353637function patch(oldVnode, vnode, hydrating, removeOnly) &#123; if (isUndef(vnode)) &#123; // 没有新节点，直接执行destory钩子函数 if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return &#125; let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) &#123; isInitialPatch = true createElm(vnode, insertedVnodeQueue) // 没有旧节点，直接用新节点生成dom元素 &#125; else &#123; const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // 判断旧节点和新节点自身一样，一致执行patchVnode patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) &#125; else &#123; // 否则直接销毁及旧节点，根据新节点生成dom元素 if (isRealElement) &#123; if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123; oldVnode.removeAttribute(SSR_ATTR) hydrating = true &#125; if (isTrue(hydrating)) &#123; if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123; invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode &#125; &#125; oldVnode = emptyNodeAt(oldVnode) &#125; return vnode.elm &#125; &#125;&#125; patch函数前两个参数位为oldVnode 和 Vnode ，分别代表新的节点和之前的旧节点，主要做了四个判断： 没有新节点，直接触发旧节点的destory钩子 没有旧节点，说明是页面刚开始初始化的时候，此时，根本不需要比较了，直接全是新建，所以只调用 createElm 旧节点和新节点自身一样，通过 sameVnode 判断节点是否一样，一样时，直接调用 patchVnode去处理这两个节点 旧节点和新节点自身不一样，当两个节点不一样的时候，直接创建新节点，删除旧节点 下面主要讲的是patchVnode部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123; // 如果新旧节点一致，什么都不做 if (oldVnode === vnode) &#123; return &#125; // 让vnode.el引用到现在的真实dom，当el修改时，vnode.el会同步变化 const elm = vnode.elm = oldVnode.elm // 异步占位符 if (isTrue(oldVnode.isAsyncPlaceholder)) &#123; if (isDef(vnode.asyncFactory.resolved)) &#123; hydrate(oldVnode.elm, vnode, insertedVnodeQueue) &#125; else &#123; vnode.isAsyncPlaceholder = true &#125; return &#125; // 如果新旧都是静态节点，并且具有相同的key // 当vnode是克隆节点或是v-once指令控制的节点时，只需要把oldVnode.elm和oldVnode.child都复制到vnode上 // 也不用再有其他操作 if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) &#123; vnode.componentInstance = oldVnode.componentInstance return &#125; let i const data = vnode.data if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123; i(oldVnode, vnode) &#125; const oldCh = oldVnode.children const ch = vnode.children if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123; for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) &#125; // 如果vnode不是文本节点或者注释节点 if (isUndef(vnode.text)) &#123; // 并且都有子节点 if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // 并且子节点不完全一致，则调用updateChildren if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) // 如果只有新的vnode有子节点 &#125; else if (isDef(ch)) &#123; if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#x27;&#x27;) // elm已经引用了老的dom节点，在老的dom节点上添加子节点 addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) // 如果新vnode没有子节点，而vnode有子节点，直接删除老的oldCh &#125; else if (isDef(oldCh)) &#123; removeVnodes(elm, oldCh, 0, oldCh.length - 1) // 如果老节点是文本节点 &#125; else if (isDef(oldVnode.text)) &#123; nodeOps.setTextContent(elm, &#x27;&#x27;) &#125; // 如果新vnode和老vnode是文本节点或注释节点 // 但是vnode.text != oldVnode.text时，只需要更新vnode.elm的文本内容就可以 &#125; else if (oldVnode.text !== vnode.text) &#123; nodeOps.setTextContent(elm, vnode.text) &#125; if (isDef(data)) &#123; if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode) &#125; &#125; patchVnode主要做了几个判断： 新节点是否是文本节点，如果是，则直接更新dom的文本内容为新节点的文本内容 新节点和旧节点如果都有子节点，则处理比较更新子节点 只有新节点有子节点，旧节点没有，那么不用比较了，所有节点都是全新的，所以直接全部新建就好了，新建是指创建出所有新DOM，并且添加进父节点 只有旧节点有子节点而新节点没有，说明更新后的页面，旧节点全部都不见了，那么要做的，就是把所有的旧节点删除，也就是直接把DOM 删除 子节点不完全一致，则调用updateChildren 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; let oldStartIdx = 0 // 旧头索引 let newStartIdx = 0 // 新头索引 let oldEndIdx = oldCh.length - 1 // 旧尾索引 let newEndIdx = newCh.length - 1 // 新尾索引 let oldStartVnode = oldCh[0] // oldVnode的第一个child let oldEndVnode = oldCh[oldEndIdx] // oldVnode的最后一个child let newStartVnode = newCh[0] // newVnode的第一个child let newEndVnode = newCh[newEndIdx] // newVnode的最后一个child let oldKeyToIdx, idxInOld, vnodeToMove, refElm // removeOnly is a special flag used only by &lt;transition-group&gt; // to ensure removed elements stay in correct relative positions // during leaving transitions const canMove = !removeOnly // 如果oldStartVnode和oldEndVnode重合，并且新的也都重合了，证明diff完了，循环结束 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // 如果oldVnode的第一个child不存在 if (isUndef(oldStartVnode)) &#123; // oldStart索引右移 oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left // 如果oldVnode的最后一个child不存在 &#125; else if (isUndef(oldEndVnode)) &#123; // oldEnd索引左移 oldEndVnode = oldCh[--oldEndIdx] // oldStartVnode和newStartVnode是同一个节点 &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; // patch oldStartVnode和newStartVnode， 索引左移，继续循环 patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] // oldEndVnode和newEndVnode是同一个节点 &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; // patch oldEndVnode和newEndVnode，索引右移，继续循环 patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] // oldStartVnode和newEndVnode是同一个节点 &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right // patch oldStartVnode和newEndVnode patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue) // 如果removeOnly是false，则将oldStartVnode.eml移动到oldEndVnode.elm之后 canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) // oldStart索引右移，newEnd索引左移 oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] // 如果oldEndVnode和newStartVnode是同一个节点 &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left // patch oldEndVnode和newStartVnode patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue) // 如果removeOnly是false，则将oldEndVnode.elm移动到oldStartVnode.elm之前 canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) // oldEnd索引左移，newStart索引右移 oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] // 如果都不匹配 &#125; else &#123; if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 尝试在oldChildren中寻找和newStartVnode的具有相同的key的Vnode idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) // 如果未找到，说明newStartVnode是一个新的节点 if (isUndef(idxInOld)) &#123; // New element // 创建一个新Vnode createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) // 如果找到了和newStartVnodej具有相同的key的Vnode，叫vnodeToMove &#125; else &#123; vnodeToMove = oldCh[idxInOld] /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !vnodeToMove) &#123; warn( &#x27;It seems there are duplicate keys that is causing an update error. &#x27; + &#x27;Make sure each v-for item has a unique key.&#x27; ) &#125; // 比较两个具有相同的key的新节点是否是同一个节点 //不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。 if (sameVnode(vnodeToMove, newStartVnode)) &#123; // patch vnodeToMove和newStartVnode patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue) // 清除 oldCh[idxInOld] = undefined // 如果removeOnly是false，则将找到的和newStartVnodej具有相同的key的Vnode，叫vnodeToMove.elm // 移动到oldStartVnode.elm之前 canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) // 如果key相同，但是节点不相同，则创建一个新的节点 &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) &#125; &#125; // 右移 newStartVnode = newCh[++newStartIdx] &#125; &#125; while循环主要处理了以下五种情景： 当新老 VNode 节点的 start 相同时，直接 patchVnode ，同时新老 VNode 节点的开始索引都加 1 当新老 VNode 节点的 end相同时，同样直接 patchVnode ，同时新老 VNode 节点的结束索引都减 1 当老 VNode 节点的 start 和新 VNode 节点的 end 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldEndVnode 的后面，同时老 VNode 节点开始索引加 1，新 VNode 节点的结束索引减 1 当老 VNode 节点的 end 和新 VNode 节点的 start 相同时，这时候在 patchVnode 后，还需要将当前真实 dom 节点移动到 oldStartVnode 的前面，同时老 VNode 节点结束索引减 1，新 VNode 节点的开始索引加 1 如果都不满足以上四种情形，那说明没有相同的节点可以复用，则会分为以下两种情况： 从旧的 VNode 为 key 值，对应 index 序列为 value 值的哈希表中找到与 newStartVnode 一致 key 的旧的 VNode 节点，再进行patchVnode，同时将这个真实 dom移动到 oldStartVnode 对应的真实 dom 的前面 调用 createElm 创建一个新的 dom 节点放到当前 newStartIdx 的位置 小结 当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁 通过isSameVnode进行判断，相同则调用patchVnode方法 &#96;&#96;&#96;patchVnode 1234567891011 做了以下操作： - 找到对应的真实`dom`，称为`el` - 如果都有都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点 - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点 - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el` - 如果两者都有子节点，则执行`updateChildren`函数比较子节点- ``` updateChildren 主要做了以下操作： 设置新旧VNode的头尾指针 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"VUE的过滤器，自定义指令","slug":"VUE的过滤器，自定义指令","date":"2020-07-23T05:33:04.000Z","updated":"2022-10-21T00:54:56.014Z","comments":true,"path":"2020/07/23/VUE的过滤器，自定义指令/","link":"","permalink":"http://example.com/2020/07/23/VUE%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","excerpt":"","text":"是什么过滤器是什么过滤器（filter）是输送介质管道上不可缺少的一种装置 大白话，就是把一些不必要的东西过滤掉 过滤器实质不改变原始数据，只是对数据进行加工处理后返回过滤后的数据再进行调用处理，我们也可以理解其为一个纯函数 Vue 允许你自定义过滤器，可被用于一些常见的文本格式化 ps: Vue3中已废弃filter 如何用vue中的过滤器可以用在两个地方：双花括号插值和 v-bind 表达式，过滤器应该被添加在 JavaScript表达式的尾部，由“管道”符号指示： 12345&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 定义filter在组件的选项中定义本地的过滤器 1234567filters: &#123; capitalize: function (value) &#123; if (!value) return &#x27;&#x27; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125;&#125; 定义全局过滤器： 123456789Vue.filter(&#x27;capitalize&#x27;, function (value) &#123; if (!value) return &#x27;&#x27; value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1)&#125;)new Vue(&#123; // ...&#125;) 注意：当全局过滤器和局部过滤器重名时，会采用局部过滤器 过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，capitalize 过滤器函数将会收到 message 的值作为第一个参数 过滤器可以串联： 1&#123;&#123; message | filterA | filterB &#125;&#125; 在这个例子中，filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。 过滤器是 JavaScript函数，因此可以接收参数： 1&#123;&#123; message | filterA(&#x27;arg1&#x27;, arg2) &#125;&#125; 这里，filterA 被定义为接收三个参数的过滤器函数。 其中 message 的值作为第一个参数，普通字符串 &#39;arg1&#39; 作为第二个参数，表达式 arg2 的值作为第三个参数 举个例子： 1234567891011&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; msg | msgFormat(&#x27;疯狂&#x27;,&#x27;--&#x27;)&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; // 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter(&#x27;msgFormat&#x27;, function(msg, arg, arg2) &#123; // 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 return msg.replace(/单纯/g, arg+arg2) &#125;)&lt;/script&gt; 小结： 部过滤器优先于全局过滤器被调用 一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右 应用场景平时开发中，需要用到过滤器的地方有很多，比如单位转换、数字打点、文本格式化、时间格式化之类的等 比如我们要实现将30000 &#x3D;&gt; 30,000，这时候我们就需要使用过滤器 12345Vue.filter(&#x27;toThousandFilter&#x27;, function (value) &#123; if (!value) return &#x27;&#x27; value = value.toString() return .replace(str.indexOf(&#x27;.&#x27;) &gt; -1 ? /(\\d)(?=(\\d&#123;3&#125;)+\\.)/g : /(\\d)(?=(?:\\d&#123;3&#125;)+$)/g, &#x27;$1,&#x27;)&#125;) 原理分析使用过滤器 1&#123;&#123; message | capitalize &#125;&#125; 在模板编译阶段过滤器表达式将会被编译为过滤器函数，主要是用过parseFilters，我们放到最后讲 1_s(_f(&#x27;filterFormat&#x27;)(message)) 首先分析一下_f： _f 函数全名是：resolveFilter，这个函数的作用是从this.$options.filters中找出注册的过滤器并返回 12// 变为this.$options.filters[&#x27;filterFormat&#x27;](message) // message为参数 关于resolveFilter 12345import &#123; indentity,resolveAsset &#125; from &#x27;core/util/index&#x27; export function resolveFilter(id)&#123; return resolveAsset(this.$options,&#x27;filters&#x27;,id,true) || identity&#125; 内部直接调用resolveAsset，将option对象，类型，过滤器id，以及一个触发警告的标志作为参数传递，如果找到，则返回过滤器； resolveAsset的代码如下： 12345678910111213141516171819202122export function resolveAsset(options,type,id,warnMissing)&#123; // 因为我们找的是过滤器，所以在 resolveFilter函数中调用时 type 的值直接给的 &#x27;filters&#x27;,实际这个函数还可以拿到其他很多东西 if(typeof id !== &#x27;string&#x27;)&#123; // 判断传递的过滤器id 是不是字符串，不是则直接返回 return &#125; const assets = options[type] // 将我们注册的所有过滤器保存在变量中 // 接下来的逻辑便是判断id是否在assets中存在，即进行匹配 if(hasOwn(assets,id)) return assets[id] // 如找到，直接返回过滤器 // 没有找到，代码继续执行 const camelizedId = camelize(id) // 万一你是驼峰的呢 if(hasOwn(assets,camelizedId)) return assets[camelizedId] // 没找到，继续执行 const PascalCaseId = capitalize(camelizedId) // 万一你是首字母大写的驼峰呢 if(hasOwn(assets,PascalCaseId)) return assets[PascalCaseId] // 如果还是没找到，则检查原型链(即访问属性) const result = assets[id] || assets[camelizedId] || assets[PascalCaseId] // 如果依然没找到，则在非生产环境的控制台打印警告 if(process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warnMissing &amp;&amp; !result)&#123; warn(&#x27;Failed to resolve &#x27; + type.slice(0,-1) + &#x27;: &#x27; + id, options) &#125; // 无论是否找到，都返回查找结果 return result&#125; 下面再来分析一下_s： _s 函数的全称是 toString,过滤器处理后的结果会当作参数传递给 toString函数，最终 toString函数执行后的结果会保存到Vnode中的text属性中，渲染到视图中 1234567function toString(value)&#123; return value == null ? &#x27;&#x27; : typeof value === &#x27;object&#x27; ? JSON.stringify(value,null,2)// JSON.stringify()第三个参数可用来控制字符串里面的间距 : String(value)&#125; 最后，在分析下parseFilters，在模板编译阶段使用该函数阶段将模板过滤器解析为过滤器函数调用表达式 1234567891011121314151617181920212223function parseFilters (filter) &#123; let filters = filter.split(&#x27;|&#x27;) let expression = filters.shift().trim() // shift()删除数组第一个元素并将其返回，该方法会更改原数组 let i if (filters) &#123; for(i = 0;i &lt; filters.length;i++)&#123; experssion = warpFilter(expression,filters[i].trim()) // 这里传进去的expression实际上是管道符号前面的字符串，即过滤器的第一个参数 &#125; &#125; return expression&#125;// warpFilter函数实现function warpFilter(exp,filter)&#123; // 首先判断过滤器是否有其他参数 const i = filter.indexof(&#x27;(&#x27;) if(i&lt;0)&#123; // 不含其他参数，直接进行过滤器表达式字符串的拼接 return `_f(&quot;$&#123;filter&#125;&quot;)($&#123;exp&#125;)` &#125;else&#123; const name = filter.slice(0,i) // 过滤器名称 const args = filter.slice(i+1) // 参数，但还多了 ‘)’ return `_f(&#x27;$&#123;name&#125;&#x27;)($&#123;exp&#125;,$&#123;args&#125;` // 注意这一步少给了一个 &#x27;)&#x27; &#125;&#125; 小结： 在编译阶段通过parseFilters将过滤器编译成函数调用（串联过滤器则是一个嵌套的函数调用，前一个过滤器执行的结果是后一个过滤器函数的参数） 编译后通过调用resolveFilter函数找到对应过滤器并返回结果 执行结果作为参数传递给toString函数，而toString执行后，其结果会保存在Vnode的text属性中，渲染到视图 什么是指令开始之前我们先学习一下指令系统这个词 指令系统是计算机硬件的语言系统，也叫机器语言，它是系统程序员看到的计算机的主要属性。因此指令系统表征了计算机的基本功能决定了机器所要求的能力 在vue中提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统 我们看到的v-开头的行内属性，都是指令，不同的指令可以完成或实现不同的功能 除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令 指令使用的几种方式： 1234567891011121314//会实例化一个指令，但这个指令没有参数 `v-xxx`// -- 将值传到指令中`v-xxx=&quot;value&quot;` // -- 将字符串传入到指令中，如`v-html=&quot;&#x27;&lt;p&gt;内容&lt;/p&gt;&#x27;&quot;``v-xxx=&quot;&#x27;string&#x27;&quot;` // -- 传参数（`arg`），如`v-bind:class=&quot;className&quot;``v-xxx:arg=&quot;value&quot;` // -- 使用修饰符（`modifier`）`v-xxx:arg.modifier=&quot;value&quot;` 如何实现注册一个自定义指令有全局注册与局部注册 全局注册主要是通过Vue.directive方法进行注册 Vue.directive第一个参数是指令的名字（不需要写上v-前缀），第二个参数可以是对象数据，也可以是一个指令函数 12345678// 注册一个全局自定义指令 `v-focus`Vue.directive(&#x27;focus&#x27;, &#123; // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) &#123; // 聚焦元素 el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能 &#125;&#125;) 局部注册通过在组件options选项中设置directive属性 12345678directives: &#123; focus: &#123; // 指令的定义 inserted: function (el) &#123; el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能 &#125; &#125;&#125; 然后你可以在模板中任何元素上使用新的 v-focus property，如下： 1&lt;input v-focus /&gt; 自定义指令也像组件那样存在钩子函数： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中) update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用 unbind：只调用一次，指令与元素解绑时调用 所有的钩子函数的参数都有以下： el：指令所绑定的元素，可以用来直接操作 DOM &#96;&#96;&#96;binding 12345：一个对象，包含以下 property 1234567891011121314151617181920212223242526 ： - `name`：指令名，不包括 `v-` 前缀。 - `value`：指令的绑定值，例如：`v-my-directive=&quot;1 + 1&quot;` 中，绑定值为 `2`。 - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。 - `expression`：字符串形式的指令表达式。例如 `v-my-directive=&quot;1 + 1&quot;` 中，表达式为 `&quot;1 + 1&quot;`。 - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `&quot;foo&quot;`。 - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `&#123; foo: true, bar: true &#125;`- `vnode`：`Vue` 编译生成的虚拟节点- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用&gt; 除了 `el` 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 `dataset` 来进行举个例子：```html&lt;div v-demo=&quot;&#123; color: &#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;&quot;&gt;&lt;/div&gt;&lt;script&gt; Vue.directive(&#x27;demo&#x27;, function (el, binding) &#123; console.log(binding.value.color) // &quot;white&quot; console.log(binding.value.text) // &quot;hello!&quot; &#125;)&lt;/script&gt; 应用场景使用自定义指令可以满足我们日常一些场景，这里给出几个自定义指令的案例： 表单防止重复提交 图片懒加载 一键 Copy的功能 表单防止重复提交表单防止重复提交这种情况设置一个v-throttle自定义指令来实现 举个例子： 123456789101112131415161718192021// 1.设置v-throttle自定义指令Vue.directive(&#x27;throttle&#x27;, &#123; bind: (el, binding) =&gt; &#123; let throttleTime = binding.value; // 节流时间 if (!throttleTime) &#123; // 用户若不设置节流时间，则默认2s throttleTime = 2000; &#125; let cbFun; el.addEventListener(&#x27;click&#x27;, event =&gt; &#123; if (!cbFun) &#123; // 第一次执行 cbFun = setTimeout(() =&gt; &#123; cbFun = null; &#125;, throttleTime); &#125; else &#123; event &amp;&amp; event.stopImmediatePropagation(); &#125; &#125;, true); &#125;,&#125;);// 2.为button标签设置v-throttle自定义指令&lt;button @click=&quot;sayHello&quot; v-throttle&gt;提交&lt;/button&gt; 图片懒加载设置一个v-lazy自定义指令完成图片懒加载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788const LazyLoad = &#123; // install方法 install(Vue,options)&#123; // 代替图片的loading图 let defaultSrc = options.default; Vue.directive(&#x27;lazy&#x27;,&#123; bind(el,binding)&#123; LazyLoad.init(el,binding.value,defaultSrc); &#125;, inserted(el)&#123; // 兼容处理 if(&#x27;IntersectionObserver&#x27; in window)&#123; LazyLoad.observe(el); &#125;else&#123; LazyLoad.listenerScroll(el); &#125; &#125;, &#125;) &#125;, // 初始化 init(el,val,def)&#123; // data-src 储存真实src el.setAttribute(&#x27;data-src&#x27;,val); // 设置src为loading图 el.setAttribute(&#x27;src&#x27;,def); &#125;, // 利用IntersectionObserver监听el observe(el)&#123; let io = new IntersectionObserver(entries =&gt; &#123; let realSrc = el.dataset.src; if(entries[0].isIntersecting)&#123; if(realSrc)&#123; el.src = realSrc; el.removeAttribute(&#x27;data-src&#x27;); &#125; &#125; &#125;); io.observe(el); &#125;, // 监听scroll事件 listenerScroll(el)&#123; let handler = LazyLoad.throttle(LazyLoad.load,300); LazyLoad.load(el); window.addEventListener(&#x27;scroll&#x27;,() =&gt; &#123; handler(el); &#125;); &#125;, // 加载真实图片 load(el)&#123; let windowHeight = document.documentElement.clientHeight let elTop = el.getBoundingClientRect().top; let elBtm = el.getBoundingClientRect().bottom; let realSrc = el.dataset.src; if(elTop - windowHeight&lt;0&amp;&amp;elBtm &gt; 0)&#123; if(realSrc)&#123; el.src = realSrc; el.removeAttribute(&#x27;data-src&#x27;); &#125; &#125; &#125;, // 节流 throttle(fn,delay)&#123; let timer; let prevTime; return function(...args)&#123; let currTime = Date.now(); let context = this; if(!prevTime) prevTime = currTime; clearTimeout(timer); if(currTime - prevTime &gt; delay)&#123; prevTime = currTime; fn.apply(context,args); clearTimeout(timer); return; &#125; timer = setTimeout(function()&#123; prevTime = Date.now(); timer = null; fn.apply(context,args); &#125;,delay); &#125; &#125;&#125;export default LazyLoad; 一键 Copy的功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import &#123; Message &#125; from &#x27;ant-design-vue&#x27;;const vCopy = &#123; // /* bind 钩子函数，第一次绑定时调用，可以在这里做初始化设置 el: 作用的 dom 对象 value: 传给指令的值，也就是我们要 copy 的值 */ bind(el, &#123; value &#125;) &#123; el.$value = value; // 用一个全局属性来存传进来的值，因为这个值在别的钩子函数里还会用到 el.handler = () =&gt; &#123; if (!el.$value) &#123; // 值为空的时候，给出提示，我这里的提示是用的 ant-design-vue 的提示，你们随意 Message.warning(&#x27;无复制内容&#x27;); return; &#125; // 动态创建 textarea 标签 const textarea = document.createElement(&#x27;textarea&#x27;); // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域 textarea.readOnly = &#x27;readonly&#x27;; textarea.style.position = &#x27;absolute&#x27;; textarea.style.left = &#x27;-9999px&#x27;; // 将要 copy 的值赋给 textarea 标签的 value 属性 textarea.value = el.$value; // 将 textarea 插入到 body 中 document.body.appendChild(textarea); // 选中值并复制 textarea.select(); // textarea.setSelectionRange(0, textarea.value.length); const result = document.execCommand(&#x27;Copy&#x27;); if (result) &#123; Message.success(&#x27;复制成功&#x27;); &#125; document.body.removeChild(textarea); &#125;; // 绑定点击事件，就是所谓的一键 copy 啦 el.addEventListener(&#x27;click&#x27;, el.handler); &#125;, // 当传进来的值更新的时候触发 componentUpdated(el, &#123; value &#125;) &#123; el.$value = value; &#125;, // 指令与元素解绑的时候，移除事件绑定 unbind(el) &#123; el.removeEventListener(&#x27;click&#x27;, el.handler); &#125;,&#125;;export default vCopy; 关于自定义指令还有很多应用场景，如：拖拽指令、页面水印、权限校验等等应用场景","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue中nextTick是干什么的","slug":"vue中nextTick是干什么的","date":"2020-07-23T03:30:45.000Z","updated":"2022-10-05T06:49:52.088Z","comments":true,"path":"2020/07/23/vue中nextTick是干什么的/","link":"","permalink":"http://example.com/2020/07/23/vue%E4%B8%ADnextTick%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84/","excerpt":"","text":"NextTick是什么官方对其的定义 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM 什么意思呢？ 我们可以理解成，Vue 在更新 DOM 时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新 举例一下 Html结构 1&lt;div id=&quot;app&quot;&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; 构建一个vue实例 123456const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;原始值&#x27; &#125;&#125;) 修改message 123this.message = &#x27;修改后的值1&#x27;this.message = &#x27;修改后的值2&#x27;this.message = &#x27;修改后的值3&#x27; 这时候想获取页面最新的DOM节点，却发现获取到的是旧值 1console.log(vm.$el.textContent) // 原始值 这是因为message数据在发现变化的时候，vue并不会立刻去更新Dom，而是将修改数据的操作放在了一个异步操作队列中 如果我们一直修改相同数据，异步操作队列还会进行去重 等待同一事件循环中的所有数据变化完成之后，会将队列中的事件拿来进行处理，进行DOM的更新 为什么要有nexttick举个例子 1234&#123;&#123;num&#125;&#125;for(let i=0; i&lt;100000; i++)&#123; num = i&#125; 如果没有 nextTick 更新机制，那么 num 每次更新值都会触发视图更新(上面这段代码也就是会更新10万次视图)，有了nextTick机制，只需要更新一次，所以nextTick本质是一种优化策略 使用场景如果想要在修改数据后立刻得到更新后的DOM结构，可以使用Vue.nextTick() 第一个参数为：回调函数（可以获取最近的DOM结构） 第二个参数为：执行函数上下文 12345678// 修改数据vm.message = &#x27;修改后的值&#x27;// DOM 还没有更新console.log(vm.$el.textContent) // 原始的值Vue.nextTick(function () &#123; // DOM 更新了 console.log(vm.$el.textContent) // 修改后的值&#125;) 组件内使用 vm.$nextTick() 实例方法只需要通过this.$nextTick()，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上 12345this.message = &#x27;修改后的值&#x27;console.log(this.$el.textContent) // =&gt; &#x27;原始的值&#x27;this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; &#x27;修改后的值&#x27;&#125;) $nextTick() 会返回一个 Promise 对象，可以是用async/await完成相同作用的事情 1234this.message = &#x27;修改后的值&#x27;console.log(this.$el.textContent) // =&gt; &#x27;原始的值&#x27;await this.$nextTick()console.log(this.$el.textContent) // =&gt; &#x27;修改后的值&#x27; 实现原理源码位置：/src/core/util/next-tick.js callbacks也就是异步操作队列 callbacks新增回调函数后又执行了timerFunc函数，pending是用来标识同一个时间只能执行一次 123456789101112131415161718192021222324252627282930export function nextTick(cb?: Function, ctx?: Object) &#123; let _resolve; // cb 回调函数会经统一处理压入 callbacks 数组 callbacks.push(() =&gt; &#123; if (cb) &#123; // 给 cb 回调函数执行加上了 try-catch 错误处理 try &#123; cb.call(ctx); &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;); &#125; &#125; else if (_resolve) &#123; _resolve(ctx); &#125; &#125;); // 执行异步延迟函数 timerFunc if (!pending) &#123; pending = true; timerFunc(); &#125; // 当 nextTick 没有传入函数参数的时候，返回一个 Promise 化的调用 if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve; &#125;); &#125;&#125; timerFunc函数定义，这里是根据当前环境支持什么方法则确定调用哪个，分别有： 1Promise.then`、`MutationObserver`、`setImmediate`、`setTimeout 通过上面任意一种方法，进行降级操作 123456789101112131415161718192021222324252627282930313233343536export let isUsingMicroTask = falseif (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; //判断1：是否原生支持Promise const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; ( isNative(MutationObserver) || MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27;)) &#123; //判断2：是否原生支持MutationObserver let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; else if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123; //判断3：是否原生支持setImmediate timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; //判断4：上面都不行，直接用setTimeout timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; 无论是微任务还是宏任务，都会放到flushCallbacks使用 这里将callbacks里面的函数复制一份，同时callbacks置空 依次执行callbacks里面的函数 12345678function flushCallbacks () &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125; 小结： 把回调函数放入callbacks等待执行 将执行函数放到微任务或者宏任务中 事件循环到了微任务或者宏任务，执行函数依次执行callbacks中的回调","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue中的Vue.observable是什么","slug":"vue中的Vue-observable是什么","date":"2020-07-14T02:50:15.000Z","updated":"2022-10-05T06:50:01.830Z","comments":true,"path":"2020/07/14/vue中的Vue-observable是什么/","link":"","permalink":"http://example.com/2020/07/14/vue%E4%B8%AD%E7%9A%84Vue-observable%E6%98%AF%E4%BB%80%E4%B9%88/","excerpt":"","text":"Observable 是什么Observable 翻译过来我们可以理解成可观察的 我们先来看一下其在Vue中的定义 Vue.observable，让一个对象变成响应式数据。Vue 内部会用它来处理 data 函数返回的对象 返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新。也可以作为最小化的跨组件状态存储器 1Vue.observable(&#123; count : 1&#125;) 其作用等同于 1new vue(&#123; count : 1&#125;) 在 Vue 2.x 中，被传入的对象会直接被 Vue.observable 变更，它和被返回的对象是同一个对象 在 Vue 3.x 中，则会返回一个可响应的代理，而对源对象直接进行变更仍然是不可响应的 使用场景在非父子组件通信时，可以使用通常的bus或者使用vuex，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。这时，observable就是一个很好的选择 创建一个js文件 12345678910111213141516// 引入vueimport Vue from &#x27;vue// 创建state对象，使用observable让state对象可响应export let state = Vue.observable(&#123; name: &#x27;张三&#x27;, &#x27;age&#x27;: 38&#125;)// 创建对应的方法export let mutations = &#123; changeName(name) &#123; state.name = name &#125;, setAge(age) &#123; state.age = age &#125;&#125; 在.vue文件中直接使用即可 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; 姓名：&#123;&#123; name &#125;&#125; 年龄：&#123;&#123; age &#125;&#125; &lt;button @click=&quot;changeName(&#x27;李四&#x27;)&quot;&gt;改变姓名&lt;/button&gt; &lt;button @click=&quot;setAge(18)&quot;&gt;改变年龄&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;import &#123; state, mutations &#125; from &#x27;@/storeexport default &#123; // 在计算属性中拿到值 computed: &#123; name() &#123; return state.name &#125;, age() &#123; return state.age &#125; &#125;, // 调用mutations里面的方法，更新数据 methods: &#123; changeName: mutations.changeName, setAge: mutations.setAge &#125;&#125; 原理分析源码位置：src\\core\\observer\\index.js 1234567891011121314151617181920212223export function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void // 判断是否存在__ob__响应式属性 if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; // 实例化Observer响应式对象 ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; Observer类 12345678910111213141516171819202122export class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, &#x27;__ob__&#x27;, this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; // 实例化对象是一个对象，进入walk方法 this.walk(value) &#125;&#125; walk函数 1234567walk (obj: Object) &#123; const keys = Object.keys(obj) // 遍历key，通过defineReactive创建响应式对象 for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125;&#125; defineReactive方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; let childOb = !shallow &amp;&amp; observe(val) // 接下来调用Object.defineProperty()给对象定义响应式属性 Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) // 对观察者watchers进行通知,state就成了全局响应式对象 dep.notify() &#125; &#125;)&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue的组件通信方式","slug":"vue的组件通信方式","date":"2020-05-09T03:40:45.000Z","updated":"2022-10-05T06:49:46.192Z","comments":true,"path":"2020/05/09/vue的组件通信方式/","link":"","permalink":"http://example.com/2020/05/09/vue%E7%9A%84%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/","excerpt":"","text":"组件间通信的概念开始之前，我们把组件间通信这个词进行拆分 组件 通信 都知道组件是vue最强大的功能之一，vue中每一个.vue我们都可以视之为一个组件通信指的是发送者通过某种媒体以某种格式来传递信息到收信者以达到某个目的。广义上，任何信息的交通都是通信组件间通信即指组件(.vue)通过某种方式来传递信息以达到某个目的举个栗子我们在使用UI框架中的table组件，可能会往table组件中传入某些数据，这个本质就形成了组件之间的通信 组件间通信解决了什么在古代，人们通过驿站、飞鸽传书、烽火报警、符号、语言、眼神、触碰等方式进行信息传递，到了今天，随着科技水平的飞速发展，通信基本完全利用有线或无线电完成，相继出现了有线电话、固定电话、无线电话、手机、互联网甚至视频电话等各种通信方式从上面这段话，我们可以看到通信的本质是信息同步，共享回到vue中，每个组件之间的都有独自的作用域，组件间的数据是无法共享的但实际开发工作中我们常常需要让组件之间共享数据，这也是组件通信的目的要让它们互相之间能进行通讯，这样才能构成一个有机的完整系统 组件间通信的分类组件间通信的分类可以分成以下 父子组件之间的通信 兄弟组件之间的通信 祖孙与后代组件之间的通信 非关系组件间之间的通信 关系图: 组件间通信的方案整理vue中8种常规的通信方案 通过 props 传递 通过 $emit 触发自定义事件 使用 ref EventBus $parent 或$root attrs 与 listeners Provide 与 Inject Vuex props传递数据 适用场景：父组件传递数据给子组件 子组件设置props属性，定义接收父组件传递过来的参数 父组件在使用子组件标签中通过字面量来传递值 1234567891011Children.vueprops:&#123; // 字符串形式 name:String // 接收的类型参数 // 对象形式 age:&#123; type:Number, // 接收的类型为数值 defaule:18, // 默认值为18 require:true // age属性必须传递 &#125; &#125; Father.vue组件 1&lt;Children name=&quot;jack&quot; age=18 /&gt; $emit 触发自定义事件 适用场景：子组件传递数据给父组件 子组件通过$emit触发自定义事件，$emit第二个参数为传递的数值 父组件绑定监听器获取到子组件传递过来的参数 12Chilfen.vuethis.$emit(&#x27;add&#x27;, good) 12Father.vue&lt;Children @add=&quot;cartAdd($event)&quot; /&gt; ref 父组件在使用子组件的时候设置ref 父组件通过设置子组件ref来获取数据 父组件 123&lt;Children ref=&quot;foo&quot; /&gt; this.$refs.foo // 获取子组件实例，通过子组件实例我们就能拿到对应的数据 EventBus 使用场景：兄弟组件传值 创建一个中央事件总线EventBus 兄弟组件通过$emit触发自定义事件，$emit第二个参数为传递的数值 另一个兄弟组件通过$on监听自定义事件 123456789101112131415161718192021Bus.js// 创建一个中央时间总线类 class Bus &#123; constructor() &#123; this.callbacks = &#123;&#125;; // 存放事件的名字 &#125; $on(name, fn) &#123; this.callbacks[name] = this.callbacks[name] || []; this.callbacks[name].push(fn); &#125; $emit(name, args) &#123; if (this.callbacks[name]) &#123; this.callbacks[name].forEach((cb) =&gt; cb(args)); &#125; &#125; &#125; // main.js Vue.prototype.$bus = new Bus() // 将$bus挂载到vue实例的原型上 // 另一种方式 Vue.prototype.$bus = new Vue() // Vue已经实现了Bus的功能 12Children1.vuethis.$bus.$emit(&#x27;foo&#x27;) 12Children2.vuethis.$bus.$on(&#x27;foo&#x27;, this.handle) $parent 或$ root 通过共同祖辈$parent或者$root搭建通信桥连 兄弟组件 1this.$parent.on(&#x27;add&#x27;,this.add) 另一个兄弟组件 1this.$parent.emit(&#x27;add&#x27;) $attrs 与$ listeners 适用场景：祖先传递数据给子孙 设置批量向下传属性$attrs和 $listeners 包含了父级作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。 可以通过 v-bind=&quot;$attrs&quot; 传⼊内部组件 12345// child：并未在props中声明foo &lt;p&gt;&#123;&#123;$attrs.foo&#125;&#125;&lt;/p&gt; // parent &lt;HelloWorld foo=&quot;foo&quot;/&gt; 12345678910// 给Grandson隔代传值，communication/index.vue &lt;Child2 msg=&quot;lalala&quot; @some-event=&quot;onSomeEvent&quot;&gt;&lt;/Child2&gt; // Child2做展开 &lt;Grandson v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/Grandson&gt; // Grandson使⽤ &lt;div @click=&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from grandson&#x27;)&quot;&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; provide 与 inject 在祖先组件定义provide属性，返回传递的值 在后代组件通过inject接收组件传递过来的值 祖先组件 12345provide()&#123; return &#123; foo:&#x27;foo&#x27; &#125; &#125; 后代组件 1inject:[&#x27;foo&#x27;] // 获取到祖先组件传递过来的值 vuex 适用场景: 复杂关系的组件数据传递 Vuex作用相当于一个用来存储共享变量的容器 state用来存放共享变量的地方 getter，可以增加一个getter派生状态，(相当于store中的计算属性），用来获得共享变量的值 mutations用来存放修改state的方法。 actions也是用来存放修改state的方法，不过action是在mutations的基础上进行。常用来做一些异步操作 小结 父子关系的组件数据传递选择 props 与 $emit进行传递，也可选择ref 兄弟关系的组件数据传递可选择$bus，其次可以选择$parent进行传递 祖先与后代组件数据传递可选择attrs与listeners或者 Provide与 Inject 复杂关系的组件数据传递可以通过vuex存放共享的变量","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"关于尾递归","slug":"关于尾递归","date":"2020-05-02T13:45:48.000Z","updated":"2022-10-13T06:08:41.722Z","comments":true,"path":"2020/05/02/关于尾递归/","link":"","permalink":"http://example.com/2020/05/02/%E5%85%B3%E4%BA%8E%E5%B0%BE%E9%80%92%E5%BD%92/","excerpt":"","text":"递归递归（英语：Recursion） 在数学与计算机科学中，是指在函数的定义中使用函数自身的方法 在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数 其核心思想是把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解 一般来说，递归需要有边界条件、递归前进阶段和递归返回阶段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回 下面实现一个函数 pow(x, n)，它可以计算 x 的 n 次方 使用迭代的方式，如下： 123456789function pow(x, n) &#123; let result = 1; // 再循环中，用 x 乘以 result n 次 for (let i = 0; i &lt; n; i++) &#123; result *= x; &#125; return result;&#125; 使用递归的方式，如下： 1234567function pow(x, n) &#123; if (n == 1) &#123; return x; &#125; else &#123; return x * pow(x, n - 1); &#125;&#125; pow(x, n) 被调用时，执行分为两个分支： 12345 if n==1 = x /pow(x, n) = \\ else = x * pow(x, n - 1) 也就是说pow 递归地调用自身 直到 n == 1 为了计算 pow(2, 4)，递归变体经过了下面几个步骤： pow(2, 4) = 2 * pow(2, 3) pow(2, 3) = 2 * pow(2, 2) pow(2, 2) = 2 * pow(2, 1) pow(2, 1) = 2 因此，递归将函数调用简化为一个更简单的函数调用，然后再将其简化为一个更简单的函数，以此类推，直到结果 尾递归尾递归，即在函数尾位置调用自身（或是一个尾调用本身的其他函数等等）。尾递归也是递归的一种特殊情形。尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数 尾递归在普通尾调用的基础上，多出了2个特征： 在尾部调用的是函数自身 可通过优化，使得计算仅占用常量栈空间 在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储，递归次数过多容易造成栈溢出 这时候，我们就可以使用尾递归，即一个函数中所有递归形式的调用都出现在函数的末尾，对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误 实现一下阶乘，如果用普通的递归，如下： 123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 如果n等于5，这个方法要执行5次，才返回最终的计算表达式，这样每次都要保存这个方法，就容易造成栈溢出，复杂度为O(n) 如果我们使用尾递归，则如下： 123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 可以看到，每一次返回的就是一个新的函数，不带上一个函数的参数，也就不需要储存上一个函数了。尾递归只需要保存一个调用栈，复杂度 O(1) 应用场景数组求和 123456function sumArray(arr, total) &#123; if(arr.length === 1) &#123; return total &#125; return sum(arr, total + arr.pop())&#125; 使用尾递归优化求斐波那契数列 123456function factorial2 (n, start = 1, total = 1) &#123; if(n &lt;= 2)&#123; return total &#125; return factorial2 (n -1, total, total + start)&#125; 数组扁平化 1234567891011121314let a = [1,2,3, [1,2,3, [1,2,3]]]// 变成let a = [1,2,3,1,2,3,1,2,3]// 具体实现function flat(arr = [], result = []) &#123; arr.forEach(v =&gt; &#123; if(Array.isArray(v)) &#123; result = result.concat(flat(v, [])) &#125;else &#123; result.push(v) &#125; &#125;) return result&#125; 数组对象格式化 123456789101112131415161718192021222324252627282930313233343536373839404142let obj = &#123; a: &#x27;1&#x27;, b: &#123; c: &#x27;2&#x27;, D: &#123; E: &#x27;3&#x27; &#125; &#125;&#125;// 转化为如下：let obj = &#123; a: &#x27;1&#x27;, b: &#123; c: &#x27;2&#x27;, d: &#123; e: &#x27;3&#x27; &#125; &#125;&#125;// 代码实现function keysLower(obj) &#123; let reg = new RegExp(&quot;([A-Z]+)&quot;, &quot;g&quot;); for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; let temp = obj[key]; if (reg.test(key.toString())) &#123; // 将修改后的属性名重新赋值给temp，并在对象obj内添加一个转换后的属性 temp = obj[key.replace(reg, function (result) &#123; return result.toLowerCase() &#125;)] = obj[key]; // 将之前大写的键属性删除 delete obj[key]; &#125; // 如果属性是对象或者数组，重新执行函数 if (typeof temp === &#x27;object&#x27; || Object.prototype.toString.call(temp) === &#x27;[object Array]&#x27;) &#123; keysLower(temp); &#125; &#125; &#125; return obj;&#125;;","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"组件化和模块化","slug":"组件化和模块化","date":"2020-03-11T05:11:31.000Z","updated":"2022-10-12T01:20:33.049Z","comments":true,"path":"2020/03/11/组件化和模块化/","link":"","permalink":"http://example.com/2020/03/11/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"一、什么是组件和模块1.1组件：把重复的代码提取出来合并成为一个个组件，组件最重要的就是重用（复用），位于框架最底层，其他功能都依赖于组件，可供不同功能使用，独立性强。1.2模块：分属同一功能&#x2F;业务的代码进行隔离（分装）成独立的模块，可以独立运行，以页面、功能或其他不同粒度划分程度不同的模块，位于业务框架层，模块间通过接口调用，目的是降低模块间的耦合，由之前的主应用与模块耦合，变为主应用与接口耦合，接口与模块耦合。模块就像有多个USB插口的充电宝，可以和多部手机充电，接口可以随意插拔。复用性很强，可以独立管理。 二、组件和模块的区别2.1组件：就像一个个小的单位，多个组件可以组合成组件库，方便调用和复用，组件间也可以嵌套，小组件组合成大组件。2.2模块：就像是独立的功能和项目（如淘宝：注册、登录、购物、直播…），可以调用组件来组成模块，多个模块可以组合成业务框架。 三、为什么要使用组件化和模块化？3.1开发和调试效率高：随着功能越来越多，代码结构会越发复杂，要修改某一个小功能，可能要重新翻阅整个项目的代码，把所有相同的地方都修改一遍，重复劳动浪费时间和人力，效率低；使用组件化，每个相同的功能结构都调用同一个组件，只需要修改这个组件，即可全局修改。3.2可维护性强：便于后期代码查找和维护。3.3避免阻断：模块化是可以独立运行的，如果一个模块产生了bug，不会影响其他模块的调用。3.4版本管理更容易：如果由多人协作开发，可以避免代码覆盖和冲突。 总结：组件：把重复的代码提取出来合并成为一个个组件，组件最重要的就是重用（复用）模块：分属同一功能&#x2F;业务的代码进行隔离（分装）成独立的模块，可以独立运行，独立管理，每个模块有很多接口，可供调用组件化模块化优点：开发调试效率高、可维护性强、避免阻断、版本管理更容易","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"虚拟DOM如何实现","slug":"虚拟DOM如何实现","date":"2020-03-01T11:21:09.000Z","updated":"2022-10-12T01:17:04.058Z","comments":true,"path":"2020/03/01/虚拟DOM如何实现/","link":"","permalink":"http://example.com/2020/03/01/%E8%99%9A%E6%8B%9FDOM%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"什么是虚拟DOM虚拟 DOM （Virtual DOM ）这个概念相信大家都不陌生，从 React 到 Vue ，虚拟 DOM 为这两个框架都带来了跨平台的能力（React-Native 和 Weex） 实际上它只是一层对真实DOM的抽象，以JavaScript 对象 (VNode 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上 在Javascript对象中，虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别 创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应 在vue中同样使用到了虚拟DOM技术 定义真实DOM 1234&lt;div id=&quot;app&quot;&gt; &lt;p class=&quot;p&quot;&gt;节点内容&lt;/p&gt; &lt;h3&gt;&#123;&#123; foo &#125;&#125;&lt;/h3&gt;&lt;/div&gt; 实例化vue 123456const app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; foo:&quot;foo&quot; &#125;&#125;) 观察render的render，我们能得到虚拟DOM 1234(function anonymous() &#123; with(this)&#123;return _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;id&quot;:&quot;app&quot;&#125;&#125;,[_c(&#x27;p&#x27;,&#123;staticClass:&quot;p&quot;&#125;, [_v(&quot;节点内容&quot;)]),_v(&quot; &quot;),_c(&#x27;h3&#x27;,[_v(_s(foo))])])&#125;&#125;) 通过VNode，vue可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过diff算法得出一些需要修改的最小单位,再更新视图，减少了dom操作，提高了性能 为什么需要虚拟DOMDOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的 真实的DOM节点，哪怕一个最简单的div也包含着很多属性，可以打印出来直观感受一下： 由此可见，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验 举个例子： 你用传统的原生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程 当你在一次操作时，需要更新10个DOM节点，浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程 而通过VNode，同样更新10个DOM节点，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，避免大量的无谓计算 很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI 如何实现虚拟DOM首先可以看看vue中VNode的结构 源码位置：src&#x2F;core&#x2F;vdom&#x2F;vnode.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export default class VNode &#123; tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component&#x27;s scope functionalContext: Component | void; // only for functional component root nodes key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? constructor ( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions ) &#123; /*当前节点的标签名*/ this.tag = tag /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/ this.data = data /*当前节点的子节点，是一个数组*/ this.children = children /*当前节点的文本*/ this.text = text /*当前虚拟节点对应的真实dom节点*/ this.elm = elm /*当前节点的名字空间*/ this.ns = undefined /*编译作用域*/ this.context = context /*函数化组件作用域*/ this.functionalContext = undefined /*节点的key属性，被当作节点的标志，用以优化*/ this.key = data &amp;&amp; data.key /*组件的option选项*/ this.componentOptions = componentOptions /*当前节点对应的组件的实例*/ this.componentInstance = undefined /*当前节点的父节点*/ this.parent = undefined /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/ this.raw = false /*静态节点标志*/ this.isStatic = false /*是否作为跟节点插入*/ this.isRootInsert = true /*是否为注释节点*/ this.isComment = false /*是否为克隆节点*/ this.isCloned = false /*是否有v-once指令*/ this.isOnce = false &#125; // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next https://github.com/answershuto/learnVue*/ get child (): Component | void &#123; return this.componentInstance &#125;&#125; 这里对VNode进行稍微的说明： 所有对象的 context 选项都指向了 Vue 实例 elm 属性则指向了其相对应的真实 DOM 节点 1vue`是通过`createElement`生成`VNode 源码位置：src&#x2F;core&#x2F;vdom&#x2F;create-element.js 123456789101112131415161718export function createElement ( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean): VNode | Array&lt;VNode&gt; &#123; if (Array.isArray(data) || isPrimitive(data)) &#123; normalizationType = children children = data data = undefined &#125; if (isTrue(alwaysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE &#125; return _createElement(context, tag, data, children, normalizationType)&#125; 上面可以看到createElement 方法实际上是对 _createElement 方法的封装，对参数的传入进行了判断 12345678910111213141516171819202122232425262728293031323334353637383940export function _createElement( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode | Array&lt;VNode&gt; &#123; if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\\n` + &#x27;Always create fresh vnode data objects in each render!&#x27;, context` ) return createEmptyVNode() &#125; // object syntax in v-bind if (isDef(data) &amp;&amp; isDef(data.is)) &#123; tag = data.is &#125; if (!tag) &#123; // in case of component :is set to falsy value return createEmptyVNode() &#125; ... // support single function children as default scoped slot if (Array.isArray(children) &amp;&amp; typeof children[0] === &#x27;function&#x27; ) &#123; data = data || &#123;&#125; data.scopedSlots = &#123; default: children[0] &#125; children.length = 0 &#125; if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children) &#125; else if ( === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children) &#125; // 创建VNode ...&#125; 可以看到_createElement接收5个参数： context 表示 VNode 的上下文环境，是 Component 类型 tag 表示标签，它可以是一个字符串，也可以是一个 Component data 表示 VNode 的数据，它是一个 VNodeData 类型 children 表示当前 VNode的子节点，它是任意类型的 normalizationType 表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 render 函数是编译生成的还是用户手写的 根据normalizationType 的类型，children会有不同的定义 12345if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children)&#125; else if ( === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children)&#125; simpleNormalizeChildren方法调用场景是 render 函数是编译生成的 normalizeChildren方法调用场景分为下面两种： render 函数是用户手写的 编译 slot、v-for 的时候会产生嵌套数组 无论是simpleNormalizeChildren还是normalizeChildren都是对children进行规范（使children 变成了一个类型为 VNode 的 Array），这里就不展开说了 规范化children的源码位置在：src&#x2F;core&#x2F;vdom&#x2F;helpers&#x2F;normalzie-children.js 在规范化children后，就去创建VNode 12345678910111213141516171819202122232425let vnode, ns// 对tag进行判断if (typeof tag === &#x27;string&#x27;) &#123; let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) &#123; // 如果是内置的节点，则直接创建一个普通VNode vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) &#125; else if (isDef(Ctor = resolveAsset(context.$options, &#x27;components&#x27;, tag))) &#123; // component // 如果是component类型，则会通过createComponent创建VNode节点 vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; vnode = new VNode( tag, data, children, undefined, undefined, context ) &#125;&#125; else &#123; // direct component options / constructor vnode = createComponent(tag, data, context, children)&#125; 1createComponent`同样是创建`VNode 源码位置：src&#x2F;core&#x2F;vdom&#x2F;create-component.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394export function createComponent ( Ctor: Class&lt;Component&gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag?: string): VNode | Array&lt;VNode&gt; | void &#123; if (isUndef(Ctor)) &#123; return &#125; // 构建子类构造函数 const baseCtor = context.$options._base // plain options object: turn it into a constructor if (isObject(Ctor)) &#123; Ctor = baseCtor.extend(Ctor) &#125; // if at this stage it&#x27;s not a constructor or an async component factory, // reject. if (typeof Ctor !== &#x27;function&#x27;) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(`Invalid Component definition: $&#123;String(Ctor)&#125;`, context) &#125; return &#125; // async component let asyncFactory if (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context) if (Ctor === undefined) &#123; return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) &#125; &#125; data = data || &#123;&#125; // resolve constructor options in case global mixins are applied after // component constructor creation resolveConstructorOptions(Ctor) // transform component v-model data into props &amp; events if (isDef(data.model)) &#123; transformModel(Ctor.options, data) &#125; // extract props const propsData = extractPropsFromVNodeData(data, Ctor, tag) // functional component if (isTrue(Ctor.options.functional)) &#123; return createFunctionalComponent(Ctor, propsData, data, context, children) &#125; // extract listeners, since these needs to be treated as // child component listeners instead of DOM listeners const listeners = data.on // replace with listeners with .native modifier // so it gets processed during parent component patch. data.on = data.nativeOn if (isTrue(Ctor.options.abstract)) &#123; const slot = data.slot data = &#123;&#125; if (slot) &#123; data.slot = slot &#125; &#125; // 安装组件钩子函数，把钩子函数合并到data.hook中 installComponentHooks(data) //实例化一个VNode返回。组件的VNode是没有children的 const name = Ctor.options.name || tag const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &#x27;&#x27;&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125;, asyncFactory ) if (__WEEX__ &amp;&amp; isRecyclableComponent(vnode)) &#123; return renderRecyclableComponentTemplate(vnode) &#125; return vnode&#125; 稍微提下createComponent生成VNode的三个关键流程： 构造子类构造函数Ctor installComponentHooks安装组件钩子函数 实例化 vnode 小结createElement 创建 VNode 的过程，每个 VNode 有 children，children 每个元素也是一个VNode，这样就形成了一个虚拟树结构，用于描述真实的DOM树结构","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"js中map，set，forEach的区别","slug":"js中map，set，forEach的区别","date":"2020-02-02T14:18:02.000Z","updated":"2022-10-21T01:28:10.742Z","comments":true,"path":"2020/02/02/js中map，set，forEach的区别/","link":"","permalink":"http://example.com/2020/02/02/js%E4%B8%ADmap%EF%BC%8Cset%EF%BC%8CforEach%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"","categories":[{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"上拉加载和下拉刷新的实现","slug":"上拉加载和下拉刷新的实现","date":"2019-12-12T04:10:03.000Z","updated":"2022-10-21T01:36:14.425Z","comments":true,"path":"2019/12/12/上拉加载和下拉刷新的实现/","link":"","permalink":"http://example.com/2019/12/12/%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"前言下拉刷新和上拉加载这两种交互方式通常出现在移动端中 本质上等同于PC网页中的分页，只是交互形式不同 开源社区也有很多优秀的解决方案，如iscroll、better-scroll、pulltorefresh.js库等等 这些第三方库使用起来非常便捷 我们通过原生的方式实现一次上拉加载，下拉刷新，有助于对第三方库有更好的理解与使用 实现原理上拉加载及下拉刷新都依赖于用户交互 最重要的是要理解在什么场景，什么时机下触发交互动作 上拉加载首先可以看一张图 上拉加载的本质是页面触底，或者快要触底时的动作 判断页面触底我们需要先了解一下下面几个属性 scrollTop：滚动视窗的高度距离window顶部的距离，它会随着往上滚动而不断增加，初始值是0，它是一个变化的值 clientHeight:它是一个定值，表示屏幕可视区域的高度； scrollHeight：页面不能滚动时也是存在的,此时scrollHeight等于clientHeight。scrollHeight表示body所有元素的总长度(包括body元素自身的padding) 综上我们得出一个触底公式： 1scrollTop + clientHeight &gt;= scrollHeight 简单实现 123456789let clientHeight = document.documentElement.clientHeight; //浏览器高度let scrollHeight = document.body.scrollHeight;let scrollTop = document.documentElement.scrollTop; let distance = 50; //距离视窗还用50的时候，开始触发；if ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) &#123; console.log(&quot;开始加载数据&quot;);&#125; 下拉刷新下拉刷新的本质是页面本身置于顶部时，用户下拉时需要触发的动作 关于下拉刷新的原生实现，主要分成三步： 监听原生touchstart事件，记录其初始位置的值，e.touches[0].pageY； 监听原生touchmove事件，记录并计算当前滑动的位置值与初始位置值的差值，大于0表示向下拉动，并借助CSS3的translateY属性使元素跟随手势向下滑动对应的差值，同时也应设置一个允许滑动的最大值； 监听原生touchend事件，若此时元素滑动达到最大值，则触发callback，同时将translateY重设为0，元素回到初始位置 举个例子： Html结构如下： 1234567891011&lt;main&gt; &lt;p class=&quot;refreshText&quot;&gt;&lt;/p &gt; &lt;ul id=&quot;refreshContainer&quot;&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt; &lt;li&gt;555&lt;/li&gt; ... &lt;/ul&gt;&lt;/main&gt; 监听touchstart事件，记录初始的值 12345678910var _element = document.getElementById(&#x27;refreshContainer&#x27;), _refreshText = document.querySelector(&#x27;.refreshText&#x27;), _startPos = 0, // 初始的值 _transitionHeight = 0; // 移动的距离_element.addEventListener(&#x27;touchstart&#x27;, function(e) &#123; _startPos = e.touches[0].pageY; // 记录初始位置 _element.style.position = &#x27;relative&#x27;; _element.style.transition = &#x27;transform 0s&#x27;;&#125;, false); 监听touchmove移动事件，记录滑动差值 12345678910111213_element.addEventListener(&#x27;touchmove&#x27;, function(e) &#123; // e.touches[0].pageY 当前位置 _transitionHeight = e.touches[0].pageY - _startPos; // 记录差值 if (_transitionHeight &gt; 0 &amp;&amp; _transitionHeight &lt; 60) &#123; _refreshText.innerText = &#x27;下拉刷新&#x27;; _element.style.transform = &#x27;translateY(&#x27;+_transitionHeight+&#x27;px)&#x27;; if (_transitionHeight &gt; 55) &#123; _refreshText.innerText = &#x27;释放更新&#x27;; &#125; &#125; &#125;, false); 最后，就是监听touchend离开的事件 1234567_element.addEventListener(&#x27;touchend&#x27;, function(e) &#123; _element.style.transition = &#x27;transform 0.5s ease 1s&#x27;; _element.style.transform = &#x27;translateY(0px)&#x27;; _refreshText.innerText = &#x27;更新中...&#x27;; // todo...&#125;, false); 从上面可以看到，在下拉到松手的过程中，经历了三个阶段： 当前手势滑动位置与初始位置差值大于零时，提示正在进行下拉刷新操作 下拉到一定值时，显示松手释放后的操作提示 下拉到达设定最大值松手时，执行回调，提示正在进行更新操作 案例在实际开发中，我们更多的是使用第三方库，下面以better-scroll进行举例： HTML结构 123456789&lt;div id=&quot;position-wrapper&quot;&gt; &lt;div&gt; &lt;p class=&quot;refresh&quot;&gt;下拉刷新&lt;/p &gt; &lt;div class=&quot;position-list&quot;&gt; &lt;!--列表内容--&gt; &lt;/div&gt; &lt;p class=&quot;more&quot;&gt;查看更多&lt;/p &gt; &lt;/div&gt;&lt;/div&gt; 实例化上拉下拉插件，通过use来注册插件 12345import BScroll from &quot;@better-scroll/core&quot;;import PullDown from &quot;@better-scroll/pull-down&quot;;import PullUp from &#x27;@better-scroll/pull-up&#x27;;BScroll.use(PullDown);BScroll.use(PullUp); 实例化BetterScroll，并传入相关的参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849let pageNo = 1,pageSize = 10,dataList = [],isMore = true; var scroll= new BScroll(&quot;#position-wrapper&quot;,&#123; scrollY:true,//垂直方向滚动 click:true,//默认会阻止浏览器的原生click事件，如果需要点击，这里要设为true pullUpLoad:true,//上拉加载更多 pullDownRefresh:&#123; threshold:50,//触发pullingDown事件的位置 stop:0//下拉回弹后停留的位置 &#125;&#125;);//监听下拉刷新scroll.on(&quot;pullingDown&quot;,pullingDownHandler);//监测实时滚动scroll.on(&quot;scroll&quot;,scrollHandler);//上拉加载更多scroll.on(&quot;pullingUp&quot;,pullingUpHandler);async function pullingDownHandler()&#123; dataList=[]; pageNo=1; isMore=true; $(&quot;.more&quot;).text(&quot;查看更多&quot;); await getlist();//请求数据 scroll.finishPullDown();//每次下拉结束后，需要执行这个操作 scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作&#125;async function pullingUpHandler()&#123; if(!isMore)&#123; $(&quot;.more&quot;).text(&quot;没有更多数据了&quot;); scroll.finishPullUp();//每次上拉结束后，需要执行这个操作 return; &#125; pageNo++; await this.getlist();//请求数据 scroll.finishPullUp();//每次上拉结束后，需要执行这个操作 scroll.refresh();//当滚动区域的dom结构有变化时，需要执行这个操作 &#125;function scrollHandler()&#123; if(this.y&gt;50) $(&#x27;.refresh&#x27;).text(&quot;松手开始加载&quot;); else $(&#x27;.refresh&#x27;).text(&quot;下拉刷新&quot;);&#125;function getlist()&#123; //返回的数据 let result=....; dataList=dataList.concat(result); //判断是否已加载完 if(result.length&lt;pageSize) isMore=false; //将dataList渲染到html内容中&#125; 注意点： 使用better-scroll实现下拉刷新、上拉加载时要注意以下几点： wrapper里必须只有一个子元素 子元素的高度要比wrapper要高 使用的时候，要确定DOM元素是否已经生成，必须要等到DOM渲染完成后，再new BScroll() 滚动区域的DOM元素结构有变化后，需要执行刷新 refresh() 上拉或者下拉，结束后，需要执行finishPullUp()或者finishPullDown()，否则将不会执行下次操作 better-scroll，默认会阻止浏览器的原生click事件，如果滚动内容区要添加点击事件，需要在实例化属性里设置click:true 小结下拉刷新、上拉加载原理本身都很简单，真正复杂的是封装过程中，要考虑的兼容性、易用性、性能等诸多细节","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"图片类型以及格式","slug":"图片类型","date":"2019-12-05T01:29:10.000Z","updated":"2022-10-05T01:39:39.141Z","comments":true,"path":"2019/12/05/图片类型/","link":"","permalink":"http://example.com/2019/12/05/%E5%9B%BE%E7%89%87%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"图片格式和区别jpgJPG格式，也可成为JPEG或者JPE格式，这是我们最常用的文件格式。在常用作图软件PS中存储的默认格式以及手机拍照的默认格式基本都是JPG格式。 优点：能将图片压缩至很小的存储空间；对色彩信息的保留较好，适用于互联网传播。 缺点：有损压缩会降低图片数据质量。 pngPNG格式也是常见的一种图片格式，最主要的特点是支持透明背景。这在PS设计中经常使用到，比如当我们需要制作一个透明背景logo时，如果存储为JPG格式背景会呈现白色，而存储为PNG格式则会变成透明背景。 优点：支持高级别无损耗压缩；支持透明背景。 缺点：对旧浏览器和软件兼容性较差。 gifGIF是一种压缩图片格式，分为动态GIF和静态GIF。动态GIF对于小伙伴来说并不陌生，这就是日常所用表情包的格式。这就是它的优点所在，可以支持动态图片并且支持透明背景。相比于动画，GIF格式图片存储空间小，加载速度快。 优点：支持动态和静态展示；图片存储空间小，加载速度快；支持透明背景。 缺点：有损压缩会降低图片数据质量。","categories":[{"name":"img","slug":"img","permalink":"http://example.com/categories/img/"}],"tags":[{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"}]},{"title":"定位方式","slug":"定位方式","date":"2019-11-15T05:29:30.000Z","updated":"2022-10-05T06:50:08.108Z","comments":true,"path":"2019/11/15/定位方式/","link":"","permalink":"http://example.com/2019/11/15/%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"定位的几种方式静态定位 - static相对定位 - relative绝对定位 - absolute固定定位 - fixed 静态定位静态定位是css中的默认定位方式，也就是没有定位。在此定位方式中设置：top，bottom，left，right，z-index 这些属性都是无效的。 相对定位相对定位不脱离文档流，参考自身静态位置通过 top(上),bottom（下）,left（左）,right（右） 定位，并且可以通过z-index进行层次分级。 绝对定位绝对定位脱离文档流，通过 top,bottom,left,right 定位。选取其最近的父级定位元素，当父级 position 为 static 时，absolute元素将以body坐标原点进行定位，可以通过z-index进行层次分级。 固定定位固定定位，这里他所固定的对像是浏览器可视窗口而并非是body或是父级元素。可通过z-index进行层次分级。","categories":[{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[{"name":"定位","slug":"定位","permalink":"http://example.com/tags/%E5%AE%9A%E4%BD%8D/"}]},{"title":"浮动的方法以及作用","slug":"浮动的方法以及作用","date":"2019-11-15T01:29:10.000Z","updated":"2022-10-05T06:50:15.749Z","comments":true,"path":"2019/11/15/浮动的方法以及作用/","link":"","permalink":"http://example.com/2019/11/15/%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E4%BD%9C%E7%94%A8/","excerpt":"","text":"3.浮动的作用，以及清除浮动的方法浮动的作用：改变盒子的默认的排列方式，例如：让多个盒子排在一行，或者实现2个盒子左右排列。 浮动的特点：脱离文档流的控制移动到指定的位置，不再保留原来的位置。浮动的元素一行显示，以上边缘对齐盒子中间没有间隙。浮动的盒子具有行内块元素的作用。 需要清除浮动的情况：父盒子的高度不方便确定，但是浮动的盒子又不占具位置，导致父级盒子高度为0 ，影响到下面标准流的盒子时，就需要清除浮动。 清除浮动的方法1. 在最后一个浮动元素的末尾添加一个空的块级标签来清除浮动; 2. 为父元素添加：overflow:hidden； 3. after伪元素方法：代表网站有百度，淘宝，网易。","categories":[{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[{"name":"浮动","slug":"浮动","permalink":"http://example.com/tags/%E6%B5%AE%E5%8A%A8/"}]},{"title":"axios的原理","slug":"axios的原理","date":"2019-10-05T14:04:42.000Z","updated":"2022-10-08T00:07:05.231Z","comments":true,"path":"2019/10/05/axios的原理/","link":"","permalink":"http://example.com/2019/10/05/axios%E7%9A%84%E5%8E%9F%E7%90%86/","excerpt":"","text":"axios是什么axios 是一个轻量的 HTTP客户端 基于 XMLHttpRequest 服务来执行 HTTP 请求，支持丰富的配置，支持 Promise，支持浏览器端和 Node.js 端。自Vue2.0起，尤大宣布取消对 vue-resource 的官方推荐，转而推荐 axios。现在 axios 已经成为大部分 Vue 开发者的首选 特性 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换JSON 数据 客户端支持防御XSRF 基本使用安装 1234// 项目中安装npm install axios --S// cdn 引入&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 导入 1import axios from &#x27;axios&#x27; 发送请求 1234567891011axios(&#123; url:&#x27;xxx&#x27;, // 设置请求的地址 method:&quot;GET&quot;, // 设置请求方法 params:&#123; // get请求使用params进行参数凭借,如果是post请求用data type: &#x27;&#x27;, page: 1 &#125;&#125;).then(res =&gt; &#123; // res为后端返回的数据 console.log(res); &#125;) 并发请求axios.all([]) 12345678910111213function getUserAccount() &#123; return axios.get(&#x27;/user/12345&#x27;);&#125;function getUserPermissions() &#123; return axios.get(&#x27;/user/12345/permissions&#x27;);&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (res1, res2) &#123; // res1第一个请求的返回的内容，res2第二个请求返回的内容 // 两个请求都执行完成才会执行&#125;)); 为什么要封装axios 的 API 很友好，你完全可以很轻松地在项目中直接使用。 不过随着项目规模增大，如果每发起一次HTTP请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，都需要写一遍 这种重复劳动不仅浪费时间，而且让代码变得冗余不堪，难以维护。为了提高我们的代码质量，我们应该在项目中二次封装一下 axios 再使用 举个例子： 12345678910111213141516171819202122232425262728axios(&#x27;http://localhost:3000/data&#x27;, &#123; // 配置代码 method: &#x27;GET&#x27;, timeout: 1000, withCredentials: true, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, Authorization: &#x27;xxx&#x27;, &#125;, transformRequest: [function (data, headers) &#123; return data; &#125;], // 其他请求配置...&#125;).then((data) =&gt; &#123; // todo: 真正业务逻辑代码 console.log(data);&#125;, (err) =&gt; &#123; // 错误处理代码 if (err.response.status === 401) &#123; // handle authorization error &#125; if (err.response.status === 403) &#123; // handle server forbidden error &#125; // 其他错误处理..... console.log(err);&#125;); 12345678910111213141516171819202122232425262728 如果每个页面都发送类似的请求，都要写一堆的配置与错误处理，就显得过于繁琐了 这时候我们就需要对axios进行二次封装，让使用更为便利 如何封装封装的同时，你需要和 后端协商好一些约定，请求头，状态码，请求超时时间……. 设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分 请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务) 状态码: 根据接口返回的不同status ， 来执行不同的业务，这块需要和后端约定好 请求方法：根据get、post等方法进行一个再次封装，使用起来更为方便 请求拦截器: 根据请求的请求头设定，来决定哪些请求可以访问 响应拦截器： 这块就是根据 后端&#96;返回来的状态码判定执行不同业务 设置接口请求前缀利用node环境变量来作判断，用来区分开发、测试、生产环境 12345if (process.env.NODE_ENV === &#x27;development&#x27;) &#123; axios.defaults.baseURL = &#x27;http://dev.xxx.com&#x27;&#125; else if (process.env.NODE_ENV === &#x27;production&#x27;) &#123; axios.defaults.baseURL = &#x27;http://prod.xxx.com&#x27;&#125; 在本地调试的时候，还需要在vue.config.js文件中配置devServer实现代理转发，从而实现跨域 1234567891011devServer: &#123; proxy: &#123; &#x27;/proxyApi&#x27;: &#123; target: &#x27;http://dev.xxx.com&#x27;, changeOrigin: true, pathRewrite: &#123; &#x27;/proxyApi&#x27;: &#x27;&#x27; &#125; &#125; &#125; &#125; 设置请求头与超时时间大部分情况下，请求头都是固定的，只有少部分情况下，会需要一些特殊的请求头，这里将普适性的请求头作为基础配置。当需要特殊请求头时，将特殊请求头作为参数传入，覆盖基础配置 1234567891011121314const service = axios.create(&#123; ... timeout: 30000, // 请求 30s 超时 headers: &#123; get: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded;charset=utf-8&#x27; // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来 &#125;, post: &#123; &#x27;Content-Type&#x27;: &#x27;application/json;charset=utf-8&#x27; // 在开发中，一般还需要单点登录或者其他功能的通用请求头，可以一并配置进来 &#125; &#125;,&#125;) 封装请求方法先引入封装好的方法，在要调用的接口重新封装成一个方法暴露出去 1234567891011121314151617181920212223242526272829303132333435363738394041424344// get 请求export function httpGet(&#123; url, params = &#123;&#125;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get(url, &#123; params &#125;).then((res) =&gt; &#123; resolve(res.data) &#125;).catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;// post// post请求export function httpPost(&#123; url, data = &#123;&#125;, params = &#123;&#125;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios(&#123; url, method: &#x27;post&#x27;, transformRequest: [function (data) &#123; let ret = &#x27;&#x27; for (let it in data) &#123; ret += encodeURIComponent(it) + &#x27;=&#x27; + encodeURIComponent(data[it]) + &#x27;&amp;&#x27; &#125; return ret &#125;], // 发送的数据 data, // \burl参数 params &#125;).then(res =&gt; &#123; resolve(res.data) &#125;) &#125;)&#125; 把封装的方法放在一个api.js文件中 12import &#123; httpGet, httpPost &#125; from &#x27;./http&#x27;export const getorglist = (params = &#123;&#125;) =&gt; httpGet(&#123; url: &#x27;apps/api/org/list&#x27;, params &#125;) 12 页面中就能直接调用 123456// .vueimport &#123; getorglist &#125; from &#x27;@/assets/js/api&#x27;getorglist(&#123; id: 200 &#125;).then(res =&gt; &#123; console.log(res)&#125;) 这样可以把api统一管理起来，以后维护修改只需要在api.js文件操作即可 请求拦截器请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便 1234567891011// 请求拦截器axios.interceptors.request.use( config =&gt; &#123; // 每次发送请求之前判断是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的 token &amp;&amp; (config.headers.Authorization = token) return config &#125;, error =&gt; &#123; return Promise.error(error) &#125;) 响应拦截器响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权 1234567891011121314151617181920212223// 响应拦截器axios.interceptors.response.use(response =&gt; &#123; // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) &#123; if (response.data.code === 511) &#123; // 未授权调取授权接口 &#125; else if (response.data.code === 510) &#123; // 未登录跳转登录页 &#125; else &#123; return Promise.resolve(response) &#125; &#125; else &#123; return Promise.reject(response) &#125;&#125;, error =&gt; &#123; // 我们可以在这里对异常状态作统一处理 if (error.response.status) &#123; // 处理请求失败的情况 // 对不同返回码对相应处理 return Promise.reject(error.response) &#125;&#125;) 小结 封装是编程中很有意义的手段，简单的axios封装，就可以让我们可以领略到它的魅力 封装 axios 没有一个绝对的标准，只要你的封装可以满足你的项目需求，并且用起来方便，那就是一个好的封装方案","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js数据类型","slug":"js数据类型","permalink":"http://example.com/tags/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"SSR是做什么的","slug":"SSR是做什么的","date":"2019-10-05T13:40:09.000Z","updated":"2022-10-08T00:20:13.281Z","comments":true,"path":"2019/10/05/SSR是做什么的/","link":"","permalink":"http://example.com/2019/10/05/SSR%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84/","excerpt":"","text":"是什么Server-Side Rendering 我们称其为SSR，意为服务端渲染 指由服务侧完成页面的 HTML 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程 先来看看Web3个阶段的发展史： 传统服务端渲染SSR 单页面应用SPA 服务端渲染SSR 传统web开发网页内容在服务端渲染完成，⼀次性传输到浏览器 打开页面查看源码，浏览器拿到的是全部的dom结构 单页应用SPA单页应用优秀的用户体验，使其逐渐成为主流，页面内容由JS渲染出来，这种方式称为客户端渲染 打开页面查看源码，浏览器拿到的仅有宿主元素#app，并没有内容 服务端渲染SSRSSR解决方案，后端渲染出完整的首屏的dom结构返回，前端拿到的内容包括首屏及完整spa结构，应用激活后依然按照spa方式运行 看完前端发展，我们再看看Vue官方对SSR的解释： Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序 服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行 我们从上门解释得到以下结论： Vue SSR是一个在SPA上进行改良的服务端渲染 通过Vue SSR渲染的页面，需要在客户端激活才能实现交互 Vue SSR将包含两部分：服务端渲染的首屏，包含交互的SPA 解决了什么SSR主要解决了以下两种问题： seo：搜索引擎优先爬取页面HTML结构，使用ssr时，服务端已经生成了和业务想关联的HTML，有利于seo 首屏呈现渲染：用户无需等待页面所有js加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端） 但是使用SSR同样存在以下的缺点： 复杂度：整个项目的复杂度 库的支持性，代码兼容 性能问题 每个请求都是n个实例的创建，不然会污染，消耗会变得很大 缓存 node serve、 nginx判断当前用户有没有过期，如果没过期的话就缓存，用刚刚的结果。 降级：监控cpu、内存占用过多，就spa，返回单个的壳 服务器负载变大，相对于前后端分离服务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用 所以在我们选择是否使用SSR前，我们需要慎重问问自己这些问题： 需要SEO的页面是否只是少数几个，这些是否可以使用预渲染（Prerender SPA Plugin）实现 首屏的请求响应逻辑是否复杂，数据返回是否大量且缓慢 如何实现对于同构开发，我们依然使用webpack打包，我们要解决两个问题：服务端首屏渲染和客户端激活 这里需要生成一个服务器bundle文件用于服务端首屏渲染和一个客户端bundle文件用于客户端激活 代码结构 除了两个不同入口之外，其他结构和之前vue应用完全相同 12345678src├── router├────── index.js # 路由声明├── store├────── index.js # 全局状态├── main.js # ⽤于创建vue实例├── entry-client.js # 客户端⼊⼝，⽤于静态内容“激活”└── entry-server.js # 服务端⼊⼝，⽤于⾸屏内容渲染 路由配置 12345678910111213141516import Vue from &quot;vue&quot;;import Router from &quot;vue-router&quot;;Vue.use(Router);//导出⼯⼚函数export function createRouter() &#123; return new Router(&#123; mode: &#x27;history&#x27;, routes: [ // 客户端没有编译器，这⾥要写成渲染函数 &#123; path: &quot;/&quot;, component: &#123; render: h =&gt; h(&#x27;div&#x27;, &#x27;index page&#x27;) &#125; &#125;, &#123; path: &quot;/detail&quot;, component: &#123; render: h =&gt; h(&#x27;div&#x27;, &#x27;detail page&#x27;) &#125; &#125; ] &#125;);&#125; 主文件main.js 跟之前不同，主文件是负责创建vue实例的工厂，每次请求均会有独立的vue实例创建 1234567891011121314import Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &#123; createRouter &#125; from &quot;./router&quot;;// 导出Vue实例⼯⼚函数，为每次请求创建独⽴实例// 上下⽂⽤于给vue实例传递参数export function createApp(context) &#123; const router = createRouter(); const app = new Vue(&#123; router, context, render: h =&gt; h(App) &#125;); return &#123; app, router &#125;;&#125; 编写服务端入口src/entry-server.js 它的任务是创建Vue实例并根据传入url指定首屏 1234567891011121314import &#123; createApp &#125; from &quot;./main&quot;;// 返回⼀个函数，接收请求上下⽂，返回创建的vue实例export default context =&gt; &#123; // 这⾥返回⼀个Promise，确保路由或组件准备就绪 return new Promise((resolve, reject) =&gt; &#123; const &#123; app, router &#125; = createApp(context); // 跳转到⾸屏的地址 router.push(context.url); // 路由就绪，返回结果 router.onReady(() =&gt; &#123; resolve(app); &#125;, reject); &#125;);&#125;; 编写客户端入口entry-client.js 客户端入口只需创建vue实例并执行挂载，这⼀步称为激活 1234567import &#123; createApp &#125; from &quot;./main&quot;;// 创建vue、router实例const &#123; app, router &#125; = createApp();// 路由就绪，执⾏挂载router.onReady(() =&gt; &#123; app.$mount(&quot;#app&quot;);&#125;); 对webpack进行配置 安装依赖 1npm install webpack-node-externals lodash.merge -D 对vue.config.js进行配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 两个插件分别负责打包客户端和服务端const VueSSRServerPlugin = require(&quot;vue-server-renderer/server-plugin&quot;);const VueSSRClientPlugin = require(&quot;vue-server-renderer/client-plugin&quot;);const nodeExternals = require(&quot;webpack-node-externals&quot;);const merge = require(&quot;lodash.merge&quot;);// 根据传⼊环境变量决定⼊⼝⽂件和相应配置项const TARGET_NODE = process.env.WEBPACK_TARGET === &quot;node&quot;;const target = TARGET_NODE ? &quot;server&quot; : &quot;client&quot;;module.exports = &#123; css: &#123; extract: false &#125;, outputDir: &#x27;./dist/&#x27;+target, configureWebpack: () =&gt; (&#123; // 将 entry 指向应⽤程序的 server / client ⽂件 entry: `./src/entry-$&#123;target&#125;.js`, // 对 bundle renderer 提供 source map ⽀持 devtool: &#x27;source-map&#x27;, // target设置为node使webpack以Node适⽤的⽅式处理动态导⼊， // 并且还会在编译Vue组件时告知`vue-loader`输出⾯向服务器代码。 target: TARGET_NODE ? &quot;node&quot; : &quot;web&quot;, // 是否模拟node全局变量 node: TARGET_NODE ? undefined : false, output: &#123; // 此处使⽤Node⻛格导出模块 libraryTarget: TARGET_NODE ? &quot;commonjs2&quot; : undefined &#125;, // https://webpack.js.org/configuration/externals/#function // https://github.com/liady/webpack-node-externals // 外置化应⽤程序依赖模块。可以使服务器构建速度更快，并⽣成较⼩的打包⽂件。 externals: TARGET_NODE ? nodeExternals(&#123; // 不要外置化webpack需要处理的依赖模块。 // 可以在这⾥添加更多的⽂件类型。例如，未处理 *.vue 原始⽂件， // 还应该将修改`global`（例如polyfill）的依赖模块列⼊⽩名单 whitelist: [/\\.css$/] &#125;) : undefined, optimization: &#123; splitChunks: undefined &#125;, // 这是将服务器的整个输出构建为单个 JSON ⽂件的插件。 // 服务端默认⽂件名为 `vue-ssr-server-bundle.json` // 客户端默认⽂件名为 `vue-ssr-client-manifest.json`。 plugins: [TARGET_NODE ? new VueSSRServerPlugin() : new VueSSRClientPlugin()] &#125;), chainWebpack: config =&gt; &#123; // cli4项⽬添加 if (TARGET_NODE) &#123; config.optimization.delete(&#x27;splitChunks&#x27;) &#125; config.module .rule(&quot;vue&quot;) .use(&quot;vue-loader&quot;) .tap(options =&gt; &#123; merge(options, &#123; optimizeSSR: false &#125;); &#125;); &#125;&#125;; 对脚本进行配置，安装依赖 1npm i cross-env -D 定义创建脚本package.json 12345&quot;scripts&quot;: &#123; &quot;build:client&quot;: &quot;vue-cli-service build&quot;, &quot;build:server&quot;: &quot;cross-env WEBPACK_TARGET=node vue-cli-service build&quot;, &quot;build&quot;: &quot;npm run build:server &amp;&amp; npm run build:client&quot;&#125; 执行打包：npm run build 最后修改宿主文件/public/index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--vue-ssr-outlet--&gt; &lt;/body&gt;&lt;/html&gt; 是服务端渲染入口位置，注意不能为了好看而在前后加空格 安装vuex 1npm install -S vuex 创建vuex工厂函数 123456789101112131415import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export function createStore () &#123; return new Vuex.Store(&#123; state: &#123; count:108 &#125;, mutations: &#123; add(state)&#123; state.count += 1; &#125; &#125; &#125;)&#125; 在main.js文件中挂载store 12345678910import &#123; createStore &#125; from &#x27;./store&#x27;export function createApp (context) &#123; // 创建实例 const store = createStore() const app = new Vue(&#123; store, // 挂载 render: h =&gt; h(App) &#125;) return &#123; app, router, store &#125;&#125; 服务器端渲染的是应用程序的”快照”，如果应用依赖于⼀些异步数据，那么在开始渲染之前，需要先预取和解析好这些数据 在store进行一步数据获取 123456789101112131415161718192021export function createStore() &#123; return new Vuex.Store(&#123; mutations: &#123; // 加⼀个初始化 init(state, count) &#123; state.count = count; &#125;, &#125;, actions: &#123; // 加⼀个异步请求count的action getCount(&#123; commit &#125;) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; commit(&quot;init&quot;, Math.random() * 100); resolve(); &#125;, 1000); &#125;); &#125;, &#125;, &#125;);&#125; 组件中的数据预取逻辑 123456export default &#123; asyncData(&#123; store, route &#125;) &#123; // 约定预取逻辑编写在预取钩⼦asyncData中 // 触发 action 后，返回 Promise 以便确定请求结果 return store.dispatch(&quot;getCount&quot;); &#125;&#125;; 服务端数据预取，entry-server.js 123456789101112131415161718192021222324252627282930313233343536373839import &#123; createApp &#125; from &quot;./app&quot;;export default context =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 拿出store和router实例 const &#123; app, router, store &#125; = createApp(context); router.push(context.url); router.onReady(() =&gt; &#123; // 获取匹配的路由组件数组 const matchedComponents = router.getMatchedComponents(); // 若⽆匹配则抛出异常 if (!matchedComponents.length) &#123; return reject(&#123; code: 404 &#125;); &#125; // 对所有匹配的路由组件调⽤可能存在的`asyncData()` Promise.all( matchedComponents.map(Component =&gt; &#123; if (Component.asyncData) &#123; return Component.asyncData(&#123; store, route: router.currentRoute, &#125;); &#125; &#125;), ) .then(() =&gt; &#123; // 所有预取钩⼦ resolve 后， // store 已经填充⼊渲染应⽤所需状态 // 将状态附加到上下⽂，且 `template` 选项⽤于 renderer 时， // 状态将⾃动序列化为 `window.__INITIAL_STATE__`，并注⼊ HTML context.state = store.state; resolve(app); &#125;) .catch(reject); &#125;, reject); &#125;);&#125;; 客户端在挂载到应用程序之前，store 就应该获取到状态，entry-client.js 1234567// 导出storeconst &#123; app, router, store &#125; = createApp();// 当使⽤ template 时，context.state 将作为 window.__INITIAL_STATE__ 状态⾃动嵌⼊到最终的 HTML // 在客户端挂载到应⽤程序之前，store 就应该获取到状态：if (window.__INITIAL_STATE__) &#123; store.replaceState(window.__INITIAL_STATE__);&#125; 客户端数据预取处理，main.js 1234567891011121314Vue.mixin(&#123; beforeMount() &#123; const &#123; asyncData &#125; = this.$options; if (asyncData) &#123; // 将获取数据操作分配给 promise // 以便在组件中，我们可以在数据准备就绪后 // 通过运⾏ `this.dataPromise.then(...)` 来执⾏其他任务 this.dataPromise = asyncData(&#123; store: this.$store, route: this.$route, &#125;); &#125; &#125;,&#125;); 修改服务器启动文件 1234567891011121314151617181920212223// 获取⽂件路径const resolve = dir =&gt; require(&#x27;path&#x27;).resolve(__dirname, dir)// 第 1 步：开放dist/client⽬录，关闭默认下载index⻚的选项，不然到不了后⾯路由app.use(express.static(resolve(&#x27;../dist/client&#x27;), &#123;index: false&#125;))// 第 2 步：获得⼀个createBundleRendererconst &#123; createBundleRenderer &#125; = require(&quot;vue-server-renderer&quot;);// 第 3 步：服务端打包⽂件地址const bundle = resolve(&quot;../dist/server/vue-ssr-server-bundle.json&quot;);// 第 4 步：创建渲染器const renderer = createBundleRenderer(bundle, &#123; runInNewContext: false, // https://ssr.vuejs.org/zh/api/#runinnewcontext template: require(&#x27;fs&#x27;).readFileSync(resolve(&quot;../public/index.html&quot;), &quot;utf8&quot;), // 宿主⽂件 clientManifest: require(resolve(&quot;../dist/client/vue-ssr-clientmanifest.json&quot;)) // 客户端清单&#125;);app.get(&#x27;*&#x27;, async (req,res)=&gt;&#123; // 设置url和title两个重要参数 const context = &#123; title:&#x27;ssr test&#x27;, url:req.url &#125; const html = await renderer.renderToString(context); res.send(html)&#125;) 小结 使用ssr不存在单例模式，每次用户请求都会创建一个新的vue实例 实现ssr需要实现服务端首屏渲染和客户端激活 服务端异步获取数据 1asyncData 可以分为首屏异步获取和切换组件获取 首屏异步获取数据，在服务端预渲染的时候就应该已经完成 切换组件通过mixin混入，在beforeMount钩子完成数据获取","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"什么是html","slug":"html-1","date":"2019-10-04T13:39:34.000Z","updated":"2022-10-05T06:48:28.575Z","comments":true,"path":"2019/10/04/html-1/","link":"","permalink":"http://example.com/2019/10/04/html-1/","excerpt":"","text":"1.什么是html​ html是超文本标记语言，它包括一系列标签，通过这些标签可以将网页上的文档格式统一。html文本是由html命令组成的描述文本。html命令可以说明文字，图形，动画，声音，表格，链接。 ​ 超文本是一种组织信息的方式，它通过超级链接方法将文本中的文字、图表与其他信息媒体相关联。这些相互关联的信息媒体可能在同一文本中，也可能是其他文件，或是地理位置相距遥远的某台计算机上的文件。这种组织信息方式将分布在不同位置的信息资源用随机方式进行连接，为人们查找，检索信息提供方便。","categories":[{"name":"html","slug":"html","permalink":"http://example.com/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"}]},{"title":"css是什么","slug":"css","date":"2019-10-04T01:18:06.000Z","updated":"2022-10-05T06:47:39.622Z","comments":true,"path":"2019/10/04/css/","link":"","permalink":"http://example.com/2019/10/04/css/","excerpt":"","text":"css是什么？css指的是层叠样式表，是一种用来表现HTML或XML等文件样式的计算机语言，是用来表示html样式的一种编程语言，是可以做到网页和内容进行分离的一种样式语言；主要用来设计网页的样式，美化网页。 CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。 CSS为HTML标记语言提供了一种样式描述，定义了其中元素的显示方式。CSS在Web设计领域是一个突破。利用它可以实现修改一个小的样式更新与之相关的所有页面元素。 CSS具有以下特点：丰富的样式定义CSS提供了丰富的文档样式外观，以及设置文本和背景属性的能力；允许为任何元素创建边框，以及元素边框与其他元素间的距离，以及元素边框与元素内容间的距离；允许随意改变文本的大小写方式、修饰方式以及其他页面效果。 易于使用和修改CSS可以将样式定义在HTML元素的style属性中，也可以将其定义在HTML文档的header部分，也可以将样式声明在一个专门的CSS文件中，以供HTML页面引用。总之，CSS样式表可以将所有的样式声明统一存放，进行统一管理。 另外，可以将相同样式的元素进行归类，使用同一个样式进行定义，也可以将某个样式应用到所有同名的HTML标签中，也可以将一个CSS样式指定到某个页面元素中。如果要修改样式，我们只需要在样式列表中找到相应的样式声明进行修改。 多页面应用CSS样式表可以单独存放在一个CSS文件中，这样我们就可以在多个页面中使用同一个CSS样式表。CSS样式表理论上不属于任何页面文件，在任何页面文件中都可以将其引用。这样就可以实现多个页面风格的统一。 层叠简单的说，层叠就是对一个元素多次设置同一个样式，这将使用最后一次设置的属性值。例如对一个站点中的多个页面使用了同一套CSS样式表，而某些页面中的某些元素想使用其他样式，就可以针对这些样式单独定义一个样式表应用到页面中。这些后来定义的样式将对前面的样式设置进行重写，在浏览器中看到的将是最后面设置的样式效果。 页面压缩在使用HTML定义页面效果的网站中，往往需要大量或重复的表格和font元素形成各种规格的文字样式，这样做的后果就是会产生大量的HTML标签，从而使页面文件的大小增加。而将样式的声明单独放到CSS样式表中，可以大大的减小页面的体积，这样在加载页面时使用的时间也会大大的减少。另外，CSS样式表的复用更大程度的缩减了页面的体积，减少下载的时间。 初始化css有什么用​ 1、浏览器有兼容性问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 ​ 2、初始化CSS可以节约网页代码，节约网页下载时间；还会使得网页内容时更加方便简洁；提高编码质量。","categories":[{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"ajax原理","slug":"ajax原理","date":"2019-08-22T13:49:13.000Z","updated":"2022-10-13T06:26:02.990Z","comments":true,"path":"2019/08/22/ajax原理/","link":"","permalink":"http://example.com/2019/08/22/ajax%E5%8E%9F%E7%90%86/","excerpt":"","text":"是什么AJAX全称(Async Javascript and XML) 即异步的JavaScript 和XML，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页 Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面 流程图如下： 下面举个例子： 领导想找小李汇报一下工作，就委托秘书去叫小李，自己就接着做其他事情，直到秘书告诉他小李已经到了，最后小李跟领导汇报工作 Ajax请求数据流程与“领导想找小李汇报一下工作”类似，上述秘书就相当于XMLHttpRequest对象，领导相当于浏览器，响应数据相当于小李 浏览器可以发送HTTP请求后，接着做其他事情，等收到XHR返回来的数据再进行操作 实现过程实现 Ajax异步交互需要服务器逻辑进行配合，需要完成以下步骤： 创建 Ajax的核心对象 XMLHttpRequest对象 通过 XMLHttpRequest 对象的 open() 方法与服务端建立连接 构建请求所需的数据内容，并通过XMLHttpRequest 对象的 send() 方法发送给服务器端 通过 XMLHttpRequest 对象提供的 onreadystatechange 事件监听服务器端你的通信状态 接受并处理服务端向客户端响应的数据结果 将处理结果更新到 HTML页面中 创建XMLHttpRequest对象通过XMLHttpRequest() 构造函数用于初始化一个 XMLHttpRequest 实例对象 1const xhr = new XMLHttpRequest(); 1 与服务器建立连接通过 XMLHttpRequest 对象的 open() 方法与服务器建立连接 1xhr.open(method, url, [async][, user][, password]) 1 参数说明： method：表示当前的请求方式，常见的有GET、POST url：服务端地址 async：布尔值，表示是否异步执行操作，默认为true user: 可选的用户名用于认证用途；默认为&#96;null password: 可选的密码用于认证用途，默认为&#96;null 给服务端发送数据通过 XMLHttpRequest 对象的 send() 方法，将客户端页面的数据发送给服务端 1xhr.send([body]) 1 1body`: 在 `XHR` 请求中要发送的数据体，如果不传递数据则为 `null 如果使用GET请求发送数据的时候，需要注意如下： 将请求数据添加到open()方法中的url地址中 发送请求数据中的send()方法中参数设置为null 绑定onreadystatechange事件onreadystatechange 事件用于监听服务器端的通信状态，主要监听的属性为XMLHttpRequest.readyState , 关于XMLHttpRequest.readyState属性有五个状态，如下图显示 只要 readyState属性值一变化，就会触发一次 readystatechange 事件 XMLHttpRequest.responseText属性用于接收服务器端的响应结果 举个例子： 123456789101112const request = new XMLHttpRequest()request.onreadystatechange = function(e)&#123; if(request.readyState === 4)&#123; // 整个请求过程完毕 if(request.status &gt;= 200 &amp;&amp; request.status &lt;= 300)&#123; console.log(request.responseText) // 服务端返回的结果 &#125;else if(request.status &gt;=400)&#123; console.log(&quot;错误信息：&quot; + request.status) &#125; &#125;&#125;request.open(&#x27;POST&#x27;,&#x27;http://xxxx&#x27;)request.send() 封装通过上面对XMLHttpRequest对象的了解，下面来封装一个简单的ajax请求 1234567891011121314151617181920212223242526272829303132//封装一个ajax请求function ajax(options) &#123; //创建XMLHttpRequest对象 const xhr = new XMLHttpRequest() //初始化参数的内容 options = options || &#123;&#125; options.type = (options.type || &#x27;GET&#x27;).toUpperCase() options.dataType = options.dataType || &#x27;json&#x27; const params = options.data //发送请求 if (options.type === &#x27;GET&#x27;) &#123; xhr.open(&#x27;GET&#x27;, options.url + &#x27;?&#x27; + params, true) xhr.send(null) &#125; else if (options.type === &#x27;POST&#x27;) &#123; xhr.open(&#x27;POST&#x27;, options.url, true) xhr.send(params) //接收请求 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4) &#123; let status = xhr.status if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123; options.success &amp;&amp; options.success(xhr.responseText, xhr.responseXML) &#125; else &#123; options.fail &amp;&amp; options.fail(status) &#125; &#125; &#125;&#125; 使用方式如下 123456789101112ajax(&#123; type: &#x27;post&#x27;, dataType: &#x27;json&#x27;, data: &#123;&#125;, url: &#x27;https://xxxx&#x27;, success: function(text,xml)&#123;//请求成功后的回调函数 console.log(text) &#125;, fail: function(status)&#123;////请求失败后的回调函数 console.log(status) &#125;&#125;)","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"css3动画","slug":"css3动画","date":"2019-08-22T13:49:13.000Z","updated":"2022-10-13T06:31:37.874Z","comments":true,"path":"2019/08/22/css3动画/","link":"","permalink":"http://example.com/2019/08/22/css3%E5%8A%A8%E7%94%BB/","excerpt":"","text":"是什么CSS动画（CSS Animations）是为层叠样式表建议的允许可扩展标记语言（XML）元素使用CSS的动画的模块 即指元素从一种样式逐渐过渡为另一种样式的过程 常见的动画效果有很多，如平移、旋转、缩放等等，复杂动画则是多个简单动画的组合 css实现动画的方式，有如下几种： transition 实现渐变动画 transform 转变动画 animation 实现自定义动画 实现方式transition 实现渐变动画transition的属性如下： property:填写需要变化的css属性 duration:完成过渡效果需要的时间单位(s或者ms) timing-function:完成效果的速度曲线 delay: 动画效果的延迟触发时间 其中timing-function的值有如下： 值 描述 linear 匀速（等于 cubic-bezier(0,0,1,1)） ease 从慢到快再到慢（cubic-bezier(0.25,0.1,0.25,1)） ease-in 慢慢变快（等于 cubic-bezier(0.42,0,1,1)） ease-out 慢慢变慢（等于 cubic-bezier(0,0,0.58,1)） ease-in-out 先变快再到慢（等于 cubic-bezier(0.42,0,0.58,1)），渐显渐隐效果 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值 注意：并不是所有的属性都能使用过渡的，如display:none&lt;-&gt;display:block 举个例子，实现鼠标移动上去发生变化动画效果 1234567891011121314151617181920212223242526&lt;style&gt; .base &#123; width: 100px; height: 100px; display: inline-block; background-color: #0EA9FF; border-width: 5px; border-style: solid; border-color: #5daf34; transition-property: width, height, background-color, border-width; transition-duration: 2s; transition-timing-function: ease-in; transition-delay: 500ms; &#125; /*简写*/ /*transition: all 2s ease-in 500ms;*/ .base:hover &#123; width: 200px; height: 200px; background-color: #5daf34; border-width: 10px; border-color: #3a8ee6; &#125;&lt;/style&gt;&lt;div class=&quot;base&quot;&gt;&lt;/div&gt; transform 转变动画包含四个常用的功能： translate：位移 scale：缩放 rotate：旋转 skew：倾斜 一般配合transition过度使用 注意的是，transform不支持inline元素，使用前把它变成block 举个例子 12345678910111213141516171819202122232425&lt;style&gt; .base &#123; width: 100px; height: 100px; display: inline-block; background-color: #0EA9FF; border-width: 5px; border-style: solid; border-color: #5daf34; transition-property: width, height, background-color, border-width; transition-duration: 2s; transition-timing-function: ease-in; transition-delay: 500ms; &#125; .base2 &#123; transform: none; transition-property: transform; transition-delay: 5ms; &#125; .base2:hover &#123; transform: scale(0.8, 1.5) rotate(35deg) skew(5deg) translate(15px, 25px); &#125;&lt;/style&gt; &lt;div class=&quot;base base2&quot;&gt;&lt;/div&gt; 可以看到盒子发生了旋转，倾斜，平移，放大 animation 实现自定义动画animation是由 8 个属性的简写，分别如下： 属性 描述 属性值 animation-duration 指定动画完成一个周期所需要时间，单位秒（s）或毫秒（ms），默认是 0 animation-timing-function 指定动画计时函数，即动画的速度曲线，默认是 “ease” linear、ease、ease-in、ease-out、ease-in-out animation-delay 指定动画延迟时间，即动画何时开始，默认是 0 animation-iteration-count 指定动画播放的次数，默认是 1 animation-direction 指定动画播放的方向 默认是 normal normal、reverse、alternate、alternate-reverse animation-fill-mode 指定动画填充模式。默认是 none forwards、backwards、both animation-play-state 指定动画播放状态，正在运行或暂停。默认是 running running、pauser animation-name 指定 @keyframes 动画的名称 CSS 动画只需要定义一些关键的帧，而其余的帧，浏览器会根据计时函数插值计算出来， 通过 @keyframes 来定义关键帧 因此，如果我们想要让元素旋转一圈，只需要定义开始和结束两帧即可： 12345678@keyframes rotate&#123; from&#123; transform: rotate(0deg); &#125; to&#123; transform: rotate(360deg); &#125;&#125; from 表示最开始的那一帧，to 表示结束时的那一帧 也可以使用百分比刻画生命周期 1234567891011@keyframes rotate&#123; 0%&#123; transform: rotate(0deg); &#125; 50%&#123; transform: rotate(180deg); &#125; 100%&#123; transform: rotate(360deg); &#125;&#125; 定义好了关键帧后，下来就可以直接用它了： 1animation: rotate 2s; 总结 属性 含义 transition（过度） 用于设置元素的样式过度，和animation有着类似的效果，但细节上有很大的不同 transform（变形） 用于元素进行旋转、缩放、移动或倾斜，和设置样式的动画并没有什么关系，就相当于color一样用来设置元素的“外表” translate（移动） 只是transform的一个属性值，即移动 animation（动画） 用于设置动画属性，他是一个简写的属性，包含6个属性","categories":[{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"实现单点登录","slug":"实现单点登录","date":"2019-08-12T14:59:13.000Z","updated":"2022-10-13T06:21:51.671Z","comments":true,"path":"2019/08/12/实现单点登录/","link":"","permalink":"http://example.com/2019/08/12/%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/","excerpt":"","text":"是什么单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一 SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统 SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作 当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证 上图有四个系统，分别是Application1、Application2、Application3、和SSO，当Application1、Application2、Application3需要登录时，将跳到SSO系统，SSO系统完成登录，其他的应用系统也就随之登录了 举个例子淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录 如何实现同域名下的单点登录cookie的domain属性设置为当前域的父域，并且父域的cookie会被子域所共享。path属性默认为web应用的上下文路径 利用 Cookie 的这个特点，没错，我们只需要将Cookie的domain属性设置为父域的域名（主域名），同时将 Cookie的path属性设置为根路径，将 Session ID（或 Token）保存到父域中。这样所有的子域应用就都可以访问到这个Cookie 不过这要求应用系统的域名需建立在一个共同的主域名之下，如 tieba.baidu.com 和 map.baidu.com，它们都建立在 baidu.com这个主域名之下，那么它们就可以通过这种方式来实现单点登录 不同域名下的单点登录(一)如果是不同域的情况下，Cookie是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 Web服务 用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 token 写入 Cookie（注意这个 Cookie是认证中心的，应用系统是访问不到的） 应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心 由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了 如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录 如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL，并在跳转前生成一个 Token，拼接在目标URL 的后面，回传给目标应用系统 应用系统拿到 Token之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 Token写入Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的）当用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了 此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法 不同域名下的单点登录(二)可以选择将 Session ID （或 Token ）保存到浏览器的 LocalStorage 中，让前端在每次向后端发送请求时，主动将LocalStorage的数据传递给服务端 这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 Session ID（或 Token）放在响应体中传递给前端 单点登录完全可以在前端实现。前端拿到 Session ID（或 Token ）后，除了将它写入自己的 LocalStorage 中之外，还可以通过特殊手段将它写入多个其他域下的 LocalStorage 中 关键代码如下： 12345678910111213141516171819// 获取 tokenvar token = result.data.token; // 动态创建一个不可见的iframe，在iframe中加载一个跨域HTMLvar iframe = document.createElement(&quot;iframe&quot;);iframe.src = &quot;http://app1.com/localstorage.html&quot;;document.body.append(iframe);// 使用postMessage()方法将token传递给iframesetTimeout(function () &#123; iframe.contentWindow.postMessage(token, &quot;http://app1.com&quot;);&#125;, 4000);setTimeout(function () &#123; iframe.remove();&#125;, 6000); // 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStoragewindow.addEventListener(&#x27;message&#x27;, function (event) &#123; localStorage.setItem(&#x27;token&#x27;, event.data)&#125;, false); 前端通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage 中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取Token并在请求中携带，这样就实现了同一份Token 被多个域所共享 此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域 流程单点登录的流程图如下所示： 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户未登录，将用户引导至登录页面 用户输入用户名密码提交登录申请 sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌 sso认证中心带着令牌跳转会最初的请求地址（系统1） 系统1拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统1 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源 用户访问系统2的受保护资源 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数 sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌 系统2拿到令牌，去sso认证中心校验令牌是否有效 sso认证中心校验令牌，返回有效，注册系统2 系统2使用该令牌创建与用户的局部会话，返回受保护资源 用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话 用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心 全局会话与局部会话有如下约束关系： 局部会话存在，全局会话一定存在 全局会话存在，局部会话不一定存在 全局会话销毁，局部会话必须销毁","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"元素是否在可视区域判断","slug":"元素是否在可视区域判断","date":"2019-08-12T14:09:43.000Z","updated":"2022-10-13T06:24:24.983Z","comments":true,"path":"2019/08/12/元素是否在可视区域判断/","link":"","permalink":"http://example.com/2019/08/12/%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8F%AF%E8%A7%86%E5%8C%BA%E5%9F%9F%E5%88%A4%E6%96%AD/","excerpt":"","text":"用途可视区域即我们浏览网页的设备肉眼可见的区域，如下图 在日常开发中，我们经常需要判断目标元素是否在视窗之内或者和视窗的距离小于一个值（例如 100 px），从而实现一些常用的功能，例如： 图片的懒加载 列表的无限滚动 计算广告元素的曝光情况 可点击链接的预加载 实现方式判断一个元素是否在可视区域，我们常用的有三种办法： offsetTop、scrollTop getBoundingClientRect Intersection Observer offsetTop、scrollTopoffsetTop，元素的上外边框至包含元素的上内边框之间的像素距离，其他offset属性如下图所示： 下面再来了解下clientWidth、clientHeight： clientWidth：元素内容区宽度加上左右内边距宽度，即clientWidth = content + padding clientHeight：元素内容区高度加上上下内边距高度，即clientHeight = content + padding 这里可以看到client元素都不包括外边距 最后，关于scroll系列的属性如下： scrollWidth 和 scrollHeight 主要用于确定元素内容的实际大小 scrollLeft 和 scrollTop 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置 垂直滚动 scrollTop &gt; 0 水平滚动 scrollLeft &gt; 0 将元素的 scrollLeft 和 scrollTop 设置为 0，可以重置元素的滚动位置 注意 上述属性都是只读的，每次访问都要重新开始 下面再看看如何实现判断： 公式如下： 1el.offsetTop - document.documentElement.scrollTop &lt;= viewPortHeight 代码实现： 12345678function isInViewPortOfOne (el) &#123; // viewPortHeight 兼容所有浏览器写法 const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight const offsetTop = el.offsetTop const scrollTop = document.documentElement.scrollTop const top = offsetTop - scrollTop return top &lt;= viewPortHeight&#125; getBoundingClientRect返回值是一个 DOMRect对象，拥有left, top, right, bottom, x, y, width, 和 height属性 123456789101112const target = document.querySelector(&#x27;.target&#x27;);const clientRect = target.getBoundingClientRect();console.log(clientRect);// &#123;// bottom: 556.21875,// height: 393.59375,// left: 333,// right: 1017,// top: 162.625,// width: 684// &#125; 属性对应的关系图如下所示： 当页面发生滚动的时候，top与left属性值都会随之改变 如果一个元素在视窗之内的话，那么它一定满足下面四个条件： top 大于等于 0 left 大于等于 0 bottom 小于等于视窗高度 right 小于等于视窗宽度 实现代码如下： 1234567891011121314151617function isInViewPort(element) &#123; const viewWidth = window.innerWidth || document.documentElement.clientWidth; const viewHeight = window.innerHeight || document.documentElement.clientHeight; const &#123; top, right, bottom, left, &#125; = element.getBoundingClientRect(); return ( top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight );&#125; Intersection ObserverIntersection Observer 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比getBoundingClientRect会好很多 使用步骤主要分为两步：创建观察者和传入被观察者 创建观察者12345678910const options = &#123; // 表示重叠面积占被观察者的比例，从 0 - 1 取值， // 1 表示完全被包含 threshold: 1.0, root:document.querySelector(&#x27;#scrollArea&#x27;) // 必须是目标元素的父级元素&#125;;const callback = (entries, observer) =&gt; &#123; ....&#125;const observer = new IntersectionObserver(callback, options); 通过new IntersectionObserver创建了观察者 observer，传入的参数 callback 在重叠比例超过 threshold 时会被执行&#96; 关于callback回调函数常用属性如下： 1234567891011// 上段代码中被省略的 callbackconst callback = function(entries, observer) &#123; entries.forEach(entry =&gt; &#123; entry.time; // 触发的时间 entry.rootBounds; // 根元素的位置矩形，这种情况下为视窗位置 entry.boundingClientRect; // 被观察者的位置举行 entry.intersectionRect; // 重叠区域的位置矩形 entry.intersectionRatio; // 重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算） entry.target; // 被观察者 &#125;);&#125;; 传入被观察者通过 observer.observe(target) 这一行代码即可简单的注册被观察者 12const target = document.querySelector(&#x27;.target&#x27;);observer.observe(target); 案例分析实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色 Html结构如下： 1&lt;div class=&quot;container&quot;&gt;&lt;/div&gt; css样式如下： 12345678910.container &#123; display: flex; flex-wrap: wrap;&#125;.target &#123; margin: 5px; width: 20px; height: 20px; background: red;&#125; 往container插入1000个元素 123456789const $container = $(&quot;.container&quot;);// 插入 100000 个 &lt;div class=&quot;target&quot;&gt;&lt;/div&gt;function createTargets() &#123; const htmlString = new Array(100000) .fill(&#x27;&lt;div class=&quot;target&quot;&gt;&lt;/div&gt;&#x27;) .join(&quot;&quot;); $container.html(htmlString);&#125; 这里，首先使用getBoundingClientRect方法进行判断元素是否在可视区域 12345678function isInViewPort(element) &#123; const viewWidth = window.innerWidth || document.documentElement.clientWidth; const viewHeight = window.innerHeight || document.documentElement.clientHeight; const &#123; top, right, bottom, left &#125; = element.getBoundingClientRect(); return top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; right &lt;= viewWidth &amp;&amp; bottom &lt;= viewHeight;&#125; 然后开始监听scroll事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为yellow 12345678$(window).on(&quot;scroll&quot;, () =&gt; &#123; console.log(&quot;scroll !&quot;); $targets.each((index, element) =&gt; &#123; if (isInViewPort(element)) &#123; $(element).css(&quot;background-color&quot;, &quot;yellow&quot;); &#125; &#125;);&#125;); 通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，原因在于我们绑定了scroll事件，scroll事件伴随了大量的计算，会造成资源方面的浪费 下面通过Intersection Observer的形式同样实现相同的功能 首先创建一个观察者 1const observer = new IntersectionObserver(getYellow, &#123; threshold: 1.0 &#125;); getYellow回调函数实现对背景颜色改变，如下： 12345function getYellow(entries, observer) &#123; entries.forEach(entry =&gt; &#123; $(entry.target).css(&quot;background-color&quot;, &quot;yellow&quot;); &#125;);&#125; 最后传入观察者，即.target元素 123$targets.each((index, element) =&gt; &#123; observer.observe(element);&#125;); 可以看到功能同样完成，并且页面不会出现卡顿的情况","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"内存泄露的原因","slug":"内存泄露的原因","date":"2019-08-12T14:09:43.000Z","updated":"2022-10-13T06:19:46.336Z","comments":true,"path":"2019/08/12/内存泄露的原因/","link":"","permalink":"http://example.com/2019/08/12/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8E%9F%E5%9B%A0/","excerpt":"","text":"是什么内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存 并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费 程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存 对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃 在C语言中，因为是手动管理内存，内存泄露是经常出现的事情。 123456char * buffer;buffer = (char*) malloc(42);// Do something with bufferfree(buffer); 上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。 这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制” 垃圾回收机制Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存 原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存 通常情况下有两种实现方式： 标记清除 引用计数 标记清除JavaScript最常用的垃圾收回机制 当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“ 垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉 在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了 随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存 举个例子： 12345678var m = 0,n = 19 // 把 m,n,add() 标记为进入环境。add(m, n) // 把 a, b, c标记为进入环境。console.log(n) // a,b,c标记为离开环境，等待垃圾回收。function add(a, b) &#123; a++ var c = a + b return c&#125; 引用计数语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放 如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏 12const arr = [1, 2, 3, 4];console.log(&#x27;hello world&#x27;); 上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存 如果需要这块内存被垃圾回收机制释放，只需要设置如下： 1arr = null 通过设置arr为null，就解除了对数组[1,2,3,4]的引用，引用次数变为 0，就被垃圾回收了 小结有了垃圾回收机制，不代表不用关注内存泄露。那些很占空间的值，一旦不再用到，需要检查是否还存在对它们的引用。如果是的话，就必须手动解除引用 常见内存泄露情况意外的全局变量 123function foo(arg) &#123; bar = &quot;this is a hidden global variable&quot;;&#125; 另一种意外的全局变量可能由 this 创建： 12345function foo() &#123; this.variable = &quot;potential accidental global&quot;;&#125;// foo 调用自己，this 指向了全局对象（window）foo(); 上述使用严格模式，可以避免意外的全局变量 定时器也常会造成内存泄露 12345678var someResource = getData();setInterval(function() &#123; var node = document.getElementById(&#x27;Node&#x27;); if(node) &#123; // 处理 node 和 someResource node.innerHTML = JSON.stringify(someResource)); &#125;&#125;, 1000); 如果id为Node的元素从DOM中移除，该定时器仍会存在，同时，因为回调函数中包含对someResource的引用，定时器外面的someResource也不会被释放 包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放 1234567function bindEvent() &#123; var obj = document.createElement(&#x27;XXX&#x27;); var unused = function () &#123; console.log(obj, &#x27;闭包内引用obj obj不会被释放&#x27;); &#125;; obj = null; // 解决方法&#125; 没有清理对DOM元素的引用同样造成内存泄露 12345const refA = document.getElementById(&#x27;refA&#x27;);document.body.removeChild(refA); // dom删除了console.log(refA, &#x27;refA&#x27;); // 但是还存在引用能console出整个div 没有被回收refA = null;console.log(refA, &#x27;refA&#x27;); // 解除引用 包括使用事件监听addEventListener监听的时候，在不监听的情况下使用removeEventListener取消对事件监听","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"}]},{"title":"数组常用方法","slug":"数组常用方法","date":"2019-07-08T02:09:19.000Z","updated":"2022-10-05T06:50:25.120Z","comments":true,"path":"2019/07/08/数组常用方法/","link":"","permalink":"http://example.com/2019/07/08/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"操作方法数组基本操作可以归纳为 增、删、改、查，需要留意的是哪些方法会对原数组产生影响，哪些方法不会 增下面前三种是对原数组产生影响的增添方法，第四种则不会对原数组产生影响 push() unshift() splice() concat(） push()push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度 123let colors = []; // 创建一个数组let count = colors.push(&quot;red&quot;, &quot;green&quot;); // 推入两项console.log(count) // 2 unshift()unshift()在数组开头添加任意多个值，然后返回新的数组长度 123let colors = new Array(); // 创建一个数组let count = colors.unshift(&quot;red&quot;, &quot;green&quot;); // 从数组开头推入两项alert(count); // 2 splice传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组 1234let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;)console.log(colors) // red,yellow,orange,green,blueconsole.log(removed) // [] concat()首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组 1234let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);console.log(colors); // [&quot;red&quot;, &quot;green&quot;,&quot;blue&quot;]console.log(colors2); // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;] 删下面三种都会影响原数组，最后一项不影响原数组： pop() shift() splice() slice() pop()pop() 方法用于删除数组的最后一项，同时减少数组的length 值，返回被删除的项 1234let colors = [&quot;red&quot;, &quot;green&quot;]let item = colors.pop(); // 取得最后一项console.log(item) // greenconsole.log(colors.length) // 1 shift()shift()方法用于删除数组的第一项，同时减少数组的length 值，返回被删除的项 1234let colors = [&quot;red&quot;, &quot;green&quot;]let item = colors.shift(); // 取得第一项console.log(item) // redconsole.log(colors.length) // 1 splice()传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组 1234let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let removed = colors.splice(0,1); // 删除第一项console.log(colors); // green,blueconsole.log(removed); // red，只有一个元素的数组 slice()slice() 用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组 123456let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];let colors2 = colors.slice(1);let colors3 = colors.slice(1, 4);console.log(colors) // red,green,blue,yellow,purpleconcole.log(colors2); // green,blue,yellow,purpleconcole.log(colors3); // green,blue,yellow 改即修改原来数组的内容，常用splice splice()传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响 1234let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];let removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;); // 插入两个值，删除一个元素console.log(colors); // red,red,purple,blueconsole.log(removed); // green，只有一个元素的数组 查即查找元素，返回元素坐标或者元素值 indexOf() includes() find() indexOf()返回要查找的元素在数组中的位置，如果没找到则返回 -1 12let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.indexOf(4) // 3 includes()返回要查找的元素在数组中的位置，找到返回true，否则false 12let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];numbers.includes(4) // true find()返回第一个匹配的元素 1234567891011const people = [ &#123; name: &quot;Matt&quot;, age: 27 &#125;, &#123; name: &quot;Nicholas&quot;, age: 29 &#125;];people.find((element, index, array) =&gt; element.age &lt; 28) // // &#123;name: &quot;Matt&quot;, age: 27&#125;","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"js的数据类型","slug":"js的数据类型","date":"2019-07-07T02:09:19.000Z","updated":"2022-10-05T06:48:53.868Z","comments":true,"path":"2019/07/07/js的数据类型/","link":"","permalink":"http://example.com/2019/07/07/js%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"在JavaScript中，我们可以分成两种类型： 基本类型 复杂类型 两种类型的区别是：存储位置不同 一、基础类型基本类型主要为以下6种： Number 数值最常见的整数类型格式则为十进制，还可以设置八进制（零开头）、十六进制（0x开头） 123let intNum = 55 // 10进制的55let num1 = 070 // 8进制的56let hexNum1 = 0xA //16进制的10 浮点类型则在数值汇总必须包含小数点，还可通过科学计数法表示 1234let floatNum1 = 1.1;let floatNum2 = 0.1;let floatNum3 = .1; // 有效，但不推荐let floatNum = 3.125e7; // 等于 31250000 在数值类型中，存在一个特殊数值NaN，意为“不是数值”，用于表示本来要返回数值的操作失败了（而不是抛出错误） 12console.log(0/0); // NaNconsole.log(-0/+0); // NaN String 字符串可以使用双引号（”）、单引号（’）或反引号（&#96;）标示 123let firstName = &quot;John&quot;;let lastName = &#x27;Jacob&#x27;;let lastName = `Jingleheimerschmidt` 字符串是不可变的，意思是一旦创建，它们的值就不能变了 12let lang = &quot;Java&quot;;lang = lang + &quot;Script&quot;; // 先销毁再创建 Boolean 1Boolean`（布尔值）类型有两个字面值： `true` 和`false 通过Boolean可以将其他类型的数据转化成布尔值 规则如下： 12345数据类型 转换为 true 的值 转换为 false 的值 String 非空字符串 &quot;&quot; Number 非零数值（包括无穷值） 0 、 NaN Object 任意对象 nullUndefined N/A （不存在） undefined Undefined Undefined 类型只有一个值，就是特殊值 undefined。当使用 var或 let声明了变量但没有初始化时，就相当于给变量赋予了 undefined值 12let message;console.log(message == undefined); // true 包含undefined 值的变量跟未定义变量是有区别的 1234let message; // 这个变量被声明了，只是值为 undefinedconsole.log(message); // &quot;undefined&quot;console.log(age); // 没有声明过这个变量，报错 null 1Null`类型同样只有一个值，即特殊值 `null 逻辑上讲， null 值表示一个空对象指针，这也是给typeof传一个 null 会返回 &quot;object&quot; 的原因 12let car = null;console.log(typeof car); // &quot;object&quot; undefined 值是由 null值派生而来 1console.log(null == undefined); // true 只要变量要保存对象，而当时又没有那个对象可保存，就可用 null来填充该变量 symbol Symbol （符号）是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险 1234567let genericSymbol = Symbol();let otherGenericSymbol = Symbol();console.log(genericSymbol == otherGenericSymbol); // falselet fooSymbol = Symbol(&#x27;foo&#x27;);let otherFooSymbol = Symbol(&#x27;foo&#x27;);console.log(fooSymbol == otherFooSymbol); // false 二、引用类型复杂类型统称为Object，我们这里主要讲述下面三种： Object 创建object常用方式为对象字面量表示法，属性名可以是字符串或数值 12345let person = &#123; name: &quot;Nicholas&quot;, &quot;age&quot;: 29, 5: true&#125;; Array JavaScript数组是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。并且，数组也是动态大小的，会随着数据添加而自动增长 12let colors = [&quot;red&quot;, 2, &#123;age: 20 &#125;]colors.push(2) Functio 函数实际上是对象，每个函数都是 Function类型的实例，而 Function也有属性和方法，跟其他引用类型一样 函数存在三种常见的表达方式： 函数声明 1234// 函数声明function sum (num1, num2) &#123; return num1 + num2;&#125; 函数表达式 123let sum = function(num1, num2) &#123; return num1 + num2;&#125;; 箭头函数 函数声明和函数表达式两种方式 123let sum = (num1, num2) =&gt; &#123; return num1 + num2;&#125;; 其他引用类型除了上述说的三种之外，还包括Date、RegExp、Map、Set等 三、存储区别基本数据类型和引用数据类型存储在内存中的位置不同： 基本数据类型存储在栈中 引用类型的对象存储于堆中 当我们把变量赋值给一个变量时，解析器首先要确认的就是这个值是基本类型值还是引用类型值","categories":[{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"}],"tags":[{"name":"js数据类型","slug":"js数据类型","permalink":"http://example.com/tags/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]}],"categories":[{"name":"html","slug":"html","permalink":"http://example.com/categories/html/"},{"name":"vue","slug":"vue","permalink":"http://example.com/categories/vue/"},{"name":"js","slug":"js","permalink":"http://example.com/categories/js/"},{"name":"img","slug":"img","permalink":"http://example.com/categories/img/"},{"name":"css","slug":"css","permalink":"http://example.com/categories/css/"}],"tags":[{"name":"html","slug":"html","permalink":"http://example.com/tags/html/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"js","slug":"js","permalink":"http://example.com/tags/js/"},{"name":"定位","slug":"定位","permalink":"http://example.com/tags/%E5%AE%9A%E4%BD%8D/"},{"name":"浮动","slug":"浮动","permalink":"http://example.com/tags/%E6%B5%AE%E5%8A%A8/"},{"name":"js数据类型","slug":"js数据类型","permalink":"http://example.com/tags/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"}]}